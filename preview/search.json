[{"path":"index.html","id":"section","chapter":"","heading":"","text":"","code":""},{"path":"index.html","id":"r-pour-lépidémiologie-appliquée-et-la-santé-publique","chapter":"","heading":"R pour l’épidémiologie appliquée et la santé publique","text":"Utilisation : Ce manuel été utilisé plus d’un million de fois par 400 000 personnes dans le monde entier.Objectif: Servir de manuel de référence rapide du code R (en ligne et hors line) avec des exemples centrés sur la tâche qui traitent des problèmes épidémiologiques courants.Essayez nos tutoriels interactifs gratuits ou notre cours d’introduction synchrone et virtuel utilisé par les CDC américains, l’OMS et plus de 130 autres agences de santé et programmes de formation à l’épidémiologie sur le terrain dans le monde entier.Langues: Anglais (English), Espagnol (Español), Vietnamien (Tiếng Việt), Japonais (日本), Turc (Türkçe), Francais, Portugais (Português)Rédigé par des épidémiologistes, pour des épidémiologistes \nApplied Epi est une organisation à non lucratif et un mouvement d’épis de première ligne du monde entier. Nous écrivons pendant notre temps libre pour offrir cette ressource à la communauté. Vos encouragements et vos commentaires sont les bienvenus :Visitez notre site web et rejoignez notre liste de contacts.contact@appliedepi.org, tweeter @appliedepi, ou LinkedInSoumettre des problèmes à notre dépôt GithubNous proposons des formations R en direct dispensées par des formateurs ayant des décennies d’expérience en épidémiologie appliquée - envoyez-nous un courriel pour en discuter.","code":""},{"path":"index.html","id":"comment-utiliser-ce-manuel","chapter":"","heading":"Comment utiliser ce manuel","text":"Parcourez les pages de la table des matières ou utilisez la boîte de recherche.Cliquez sur les icônes “copier” pour copier le code.Vous pouvez suivre avec les données d’exemple de le chapitre.Version hors ligneVoir les instructions de la page Télécharger le manuel et les données.","code":""},{"path":"index.html","id":"remmerciements","chapter":"","heading":"Remmerciements","text":"Cet ouvrage est le fruit du travail d’une équipe internationale d’épidémiologistes, qui se sont appuyés sur leur expérience auprès d’organisations telles que les agences sanitaires locales, régionales, provinciales et nationales de divers pays, l’Organisation mondiale de la santé (OMS), Médecins Sans Frontières (MSF), les systèmes hospitaliers et les institutions universitaires.Ce guide n’est pas un produit approuvé par une organisation spécifique. Bien que nous nous soyons efforcés à être précis, nous ne pouvons fournir aucune garantie quant au contenu de ce livre.","code":""},{"path":"index.html","id":"auteurs-et-contributeurs","chapter":"","heading":"Auteurs et contributeurs","text":"Editeur: Neale BatraCommité éditorial Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay CampbellAuteurs et autrices: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen Lin, Olivia BoydRelecture: Pat Keating, Annick Lenglet, Margot Charette, Danielly Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao MuiangaIllustrations: Calder FongTraduction: Aminata Ndiaye, Olivia Boyd, Anais Legrand, Marie-Amelie Degail-Chabrat, Yves Amevoin, Laura Downham, Lise Grout, Margot Charette, Mathilde Mousset, Noe Guincko, Mor Ndiaye, Elysée Junior, Nerisson Joseph, Bryan Tegomoh, Marcel Woung, Amy Mikhail, Lucie Fournier, Paul-Evans Ehouman, Kelly McCain","code":""},{"path":"index.html","id":"financements","chapter":"","heading":"Financements","text":"Le manuel reçu un financement de soutien via une subvention d’urgence COVID-19 pour le renforcement des capacités de la part de TEPHINET, le réseau mondial des programmes de formation en épidémiologie de terrain (FETP).Le réseau des anciens d’EPIET (EAN) fourni un soutien administratif (Annika Wendland en particulier). EPIET est le programme européen de formation en épidémiologie d’intervention.Nous remercions tout particulièrement le Centre Opérationnel d’Amsterdam de Médecins Sans Frontières (MSF OCA) pour son soutien lors de l’élaboration de ce manuel.Cette publication été soutenue par l’accord de coopération numéro NU2GGH001873, financé par les Centers Disease Control Prevention par le biais de TEPHINET, un programme de “Task Force Global Health”. Son contenu relève de la seule responsabilité des auteurs et ne reflète pas les opinions officielles des Centers Disease Control Prevention, du Department Health Human Services, de Task Force Global Health, Inc. ou de TEPHINET.","code":""},{"path":"index.html","id":"inspirations","chapter":"","heading":"Inspirations","text":"Nous nous sommes inspiré de multiples tutoriels, livres et vignettes développés par la communauté pour développer ce manuel. Ces ressources, sont crédités dans les chapitres respectifs, mais nous souhaitons citer quelques sources d’inspiration générales que nous utilisons de manière récurrente :“R4Epis” project (une collaboration entre MSF et RECON)R Epidemics Consortium (RECON)R Data Science book (R4DS)bookdown: Authoring Books Technical Documents R MarkdownNetlify qui héberge ce site","code":""},{"path":"index.html","id":"conditions-dutilisation-et-contribution","chapter":"","heading":"Conditions d’utilisation et contribution","text":"","code":""},{"path":"index.html","id":"license","chapter":"","heading":"License","text":"Ce document est mis à disposition selon les termes de lalicence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International (CC -NC-SA 4.0) .N’hésitez pas à utiliser les contenus de ce manuel dans vos cours et formations en épidémiologie, ou à le conseiller à vos étudiants. Si vous avez des questions sur l’utilisation que vous souhaitez en faire, envoyez un courriel à contact@appliedepi.org.","code":""},{"path":"index.html","id":"citation","chapter":"","heading":"Citation","text":"Batra, Neale, et al. Epidemiologist R Handbook. 2021. ","code":""},{"path":"index.html","id":"contribuer","chapter":"","heading":"Contribuer","text":"Si vous souhaitez contribuer à cet ouvrage, veuillez d’abord nous contacter via les tickets (issues) Github ou par courriel. Nous sommes en train de développer un calendrier de mise à jour et un guide du contributeur.Veuillez noter que le projet epiRhandbook est publié avec un code de conduite du contributeur. En contribuant à ce projet, vous acceptez de vous conformer à ses conditions.","code":""},{"path":"epicurves.html","id":"epicurves","chapter":"1 Courbes épidémiques","heading":"1 Courbes épidémiques","text":"Une courbe épidémique (également connue sous le nom de “courbe épi”) est un graphique épidémiologique de base généralement utilisé pour visualiser le schéma temporel d’apparition de la maladie parmi un groupe de cas ou une épidémie.L’analyse de la courbe épi peut révéler des tendances temporelles, des valeurs aberrantes, l’ampleur de l’épidémie, la période d’exposition la plus probable, les intervalles de temps entre les générations de cas, et peut même aider à identifier le mode de transmission d’une maladie non identifie (par exemple, source ponctuelle, source commune continue, propagation de personne à personne). Une leçon en ligne sur l’interprétation des courbes épi est disponible sur le site Web du US CDC.Dans cette page, nous démontrons le paquet ggplot2 pour produire des épicurves dans R, qui permet une personnalisation avancé via des commandes plus complexes.Nous abordons également des cas d’utilisation spécifiques tels que :Les tracés de données de comptages agrégéesLe facettage ou la production de petits multiplesApplication de moyennes mobilesMontrer quelles données sont “provisoires” ou sujettes à des retards de rapportSuperposer l’incidence cumulative des cas à l’aide d’un deuxiéme axe","code":""},{"path":"epicurves.html","id":"préparation","chapter":"1 Courbes épidémiques","heading":"1.1 Préparation","text":"","code":""},{"path":"epicurves.html","id":"paquets","chapter":"1 Courbes épidémiques","heading":"Paquets","text":"Ce chunk de code montre le chargement des paquets nécessaires aux analyses. Dans ce manuel, nous mettons l’accent sur p_load() de pacman, qui installe le paquet si nécessaire et le charge pour l’utiliser. Vous pouvez également charger les paquets installs avec library() de base R. Voir la page sur R basics pour plus d’informations sur les paquets R.","code":"\npacman::p_load(\n  rio,         # import/export de fichiers\n  here,        # chemins de fichiers relatifs \n  lubridate,   # travailler avec des dates/epiweeks\n  aweek,       # paquet alternatif pour travailler avec les dates/semaines\n  #incidence2, # paquet alternatif \n  #i2extras,    # supplément à incidence2\n  scales,      # fonctions utiles pour les échelles d'axes\n  stringr,     # recherche et manipulation de chaînes de caractères\n  forcats,     # travail avec des facteurs\n  RColorBrewer,# palettes de couleurs de colorbrewer2.org\n  tidyverse    # gestion des données + graphiques ggplot2\n) "},{"path":"epicurves.html","id":"importer-des-données","chapter":"1 Courbes épidémiques","heading":"Importer des données","text":"Deux exemples de jeux de données sont utilisés dans cette section :Liste de cas individuels d’une épidémie simulée.Comptage agrégé par hôpital à partir de la même épidémie simulée.Les jeux de données sont importés à l’aide de la fonction import() du paquetage rio. Voir la page Importation et exportation pour les différentes maniéres d’importer des données.Liste de casNous importons le jeu de données des cas d’une épidémie d’Ebola simulée. Si vous souhaitez télécharger les données pour les suivre pas à pas, consultez les instructions de la page Télécharger le manuel et les données. Nous supposons que le fichier est dans le répertoire de travail, donc aucun sous-dossier n’est spécifié dans ce chemin de fichier.Les 50 premiéres lignes sont affichées ci-dessous.Comptes de cas agrégés par hôpitalPour les besoins du manuel, le jeu de données des comptages hebdomadaires agrégés par hôpital est créé à partir de la linelist avec le code suivant.Les 50 premiéres lignes sont affichées ci-dessous :","code":"\nlinelist <- import(\"linelist_cleaned.xlsx\")\n# Importez les données de comptage dans R\ncount_data <- linelist %>% \n  group_by(hospital, date_hospitalisation) %>% \n  summarize(n_cases = dplyr::n()) %>% \n  filter(date_hospitalisation > as.Date(\"2013-06-01\")) %>% \n  ungroup()"},{"path":"epicurves.html","id":"définir-les-paramétres","chapter":"1 Courbes épidémiques","heading":"Définir les paramétres","text":"Pour la production d’un rapport, vous pouvez souhaiter définir des paramétres modifiables tels que la date à laquelle les données sont actuelles (la “date des données”). Vous pouvez ensuite faire référence à l’objet data_date dans votre code lorsque vous appliquez des filtres ou dans des légendes dynamiques.","code":"\n## définit la date du rapport pour le rapport\n## note : peut étre défini à Sys.Date() pour la date actuelle\ndata_date <- as.Date(\"2015-05-15\")"},{"path":"epicurves.html","id":"vérifier-les-dates","chapter":"1 Courbes épidémiques","heading":"Vérifier les dates","text":"Vérifiez que chaque colonne de date pertinente est de la classe Date et posséde une plage de valeurs appropriée. Vous pouvez le faire simplement en utilisant hist() pour les histogrammes, ou range() avec na.rm=TRUE, ou avec ggplot() comme ci-dessous.","code":"\n# vérifier la plage de dates d'apparition\nggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset))"},{"path":"epicurves.html","id":"epicurves-avec-ggplot2","chapter":"1 Courbes épidémiques","heading":"1.2 Epicurves avec ggplot2","text":"L’utilisation de ggplot() pour construire votre épicurve permet plus de flexibilité et de personnalisation, mais nécessite plus d’efforts et de compréhension du fonctionnement de ggplot().Contrairement à l’utilisation du paquet incidence2, vous devez manuellement contrôler l’agrégation des cas par temps (en semaines, mois, etc.) et les intervalles des étiquettes sur l’axe des dates. Ceci doit étre soigneusement géré.Ces exemples utilisent un sous-ensemble de l’ensemble de données linelist - seulement les cas de l’hôpital central.Pour produire une épicurve avec ggplot(), il y trois éléments principaux :Un histogramme, avec les cas de la liste de lignes agrégés en “bins” distingués par des points de “rupture” spécifiques.Des échelles pour les axes et leurs étiquettesDes thèmes pour l’apparence du graphique, y compris les titres, les étiquettes, les légendes, etc.","code":"\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")"},{"path":"epicurves.html","id":"spécifier-les-cas-en-bacs","chapter":"1 Courbes épidémiques","heading":"Spécifier les cas en bacs","text":"Nous montrons ici comment spécifier la façon dont les cas seront agrégés dans des cases d’histogramme (“barres”). Il est important de reconnaétre que l’agrégation des cas dans les cases de l’histogramme n’est pas nécessairement les mêmes intervalles que les dates qui apparaîtront sur l’axe des abscisses.Vous trouverez ci-dessous le code le plus simple pour produire des épicurves quotidiennes et hebdomadaires.Dans la commande globale ggplot(), le jeu de données est fourni avec data =. Sur cette base, la géométrie d’un histogramme est ajoutée avec un +. Dans la commande geom_histogram(), nous mappons l’esthétique de telle sorte que la colonne date_onset soit mappée sur l’axe des x. Toujours dans geom_histogram() mais non dans aes(), nous définissons la binwidth = des bins de l’histogramme, en jours. Si cette syntaxe ggplot2 est confuse, revoyez la page sur les bases de ggplot.CAUTION: Tracer des cas hebdomadaires en utilisant binwidth = 7 fait démarrer le premier bin de 7 jours au premier cas, qui pourrait étre n’importe quel jour de la semaine ! Pour créer des semaines spécifiques, voir la section ci-dessous .Notons que le premier cas de cet ensemble de données de l’hôpital Central vu ses symptômes apparaître le :Pour spécifier manuellement les ruptures des cases de l’histogramme, n’utilisez pas l’argument binwidth =, mais fournissez un vecteur de dates à breaks =..créez le vecteur de dates avec la fonction R base seq.Date(). Cette fonction attend les arguments =, =, et =. Par exemple, la commande ci-dessous renvoie les dates mensuelles commençant le 15 janvier et se terminant le 28 juin.Ce vecteur peut étre fourni à geom_histogram() sous la forme breaks = :Une simple séquence de date hebdomadaire peut étre retournée en définissant = \"week\". Par exemple :Une alternative à la fourniture de dates de début et de fin spécifiques consiste à écrire un code dynamique pour que les bacs hebdomadaires commencent le lundi précédant le premier cas. **Nous utiliserons ces vecteurs de date dans les exemples ci-dessous.Décortiquons le code plutôt déconcertant ci-dessus :La valeur “” (date la plus ancienne de la séquence) est crée comme suit : la valeur minimale de la date (min() avec na.rm=TRUE) dans la colonne date_onset est introduite dans floor_date() du paquet lubridate. floor_date() défini sur “week” renvoie la date de début de la “semaine” de ce cas, étant donné que le jour de début de chaque semaine est un lundi (week_start = 1).De même, la valeur “” (date de fin de la séquence) est créée en utilisant la fonction inverse ceiling_date() pour retourner le lundi aprés le dernier cas.L’argument “” de seq.Date() peut étre défini sur un nombre quelconque de jours, de semaines ou de mois.Utilisez week_start = 7 pour les semaines de dimanche.Comme nous utiliserons ces vecteurs de date tout au long de cette page, nous en définissons également un pour l’ensemble du foyer (ce qui précéde ne concerne que l’hôpital central).Ces sorties seq.Date() peuvent étre utilisées pour créer les ruptures des cases de l’histogramme, mais aussi les ruptures pour les étiquettes de date, qui peuvent étre indépendantes des cases. Vous en saurez plus sur les étiquettes de date dans les sections suivantes.TIP: Pour une commande ggplot() plus simple, sauvegardez à l’avance les ruptures de bacs et les ruptures d’étiquettes de dates en tant que vecteurs nommés, et fournissez simplement leurs noms à breaks =..","code":"\n# quotidien \nggplot(data = central_data) + # set data\n  geom_histogram( # ajouter un histogramme\n    mapping = aes(x = date_onset), # map date column to x-axis\n    binwidth = 1)+ # cas groupés par 1 jour \n  labs(title = \"Central Hospital - Quotidiennement\") # titre\n\n# hebdomadaire\nggplot(data = central_data) + # set data \n  geom_histogram( # ajouter un histogramme\n      mapping = aes(x = date_onset), # mappage de la colonne date sur l'axe des x\n      binwidth = 7)+ # cas classés tous les 7 jours, à partir du premier cas ( !) \n  labs(title = \"Central Hospital - Tranches de 7 jours, à partir du premier cas\") # titre\nformat(min(central_data$date_onset, na.rm=T), \"%A %d %b, %Y\")## [1] \"Thursday 01 May, 2014\"\nmonthly_breaks <- seq.Date(from = as.Date(\"2014-02-01\"),\n                           to = as.Date(\"2015-07-15\"),\n                           by = \"months\")\n\nmonthly_breaks # print##  [1] \"2014-02-01\" \"2014-03-01\" \"2014-04-01\" \"2014-05-01\" \"2014-06-01\" \"2014-07-01\" \"2014-08-01\"\n##  [8] \"2014-09-01\" \"2014-10-01\" \"2014-11-01\" \"2014-12-01\" \"2015-01-01\" \"2015-02-01\" \"2015-03-01\"\n## [15] \"2015-04-01\" \"2015-05-01\" \"2015-06-01\" \"2015-07-01\"\n# mensuel \nggplot(data = central_data) +  \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    breaks = monthly_breaks)+ # fournit le vecteur prédéfini de breaks                    \n  labs(title = \"Bins de cas mensuels\") # titre\nweekly_breaks <- seq.Date(from = as.Date(\"2014-02-01\"),\n                          to = as.Date(\"2015-07-15\"),\n                          by = \"week\")\n# Séquence de dates hebdomadaires du lundi pour CENTRAL HOSPITAL\nweekly_breaks_central <- seq.Date(\n  from = floor_date(min(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # lundi avant le premier cas\n  to = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # lundi aprés la derniére affaire\n  by = \"week\")\n# Séquence pour l'ensemble du foyer\nweekly_breaks_all <- seq.Date(\n  from = floor_date(min(linelist$date_onset, na.rm=T), \"week\", week_start = 1), # lundi avant le premier cas\n  to = ceiling_date(max(linelist$date_onset, na.rm=T), \"week\", week_start = 1), # lundi aprés la derniére affaire\n  by = \"week\")"},{"path":"epicurves.html","id":"exemple-dépicurve-hebdomadaire","chapter":"1 Courbes épidémiques","heading":"Exemple d’épicurve hebdomadaire","text":"Vous trouverez ci-dessous un exemple de code détaillé pour produire des épicurves hebdomadaires pour les semaines du lundi, avec des barres alignées, des étiquettes de date et des lignes de grille verticales. Cette section est destinée à l’utilisateur qui besoin de code rapidement. Pour comprendre en profondeur chaque aspect (thèmes, étiquettes de date, etc.), passez aux sections suivantes. noter :Les cassures de l’histogramme sont définies avec seq.Date() comme expliqué ci-dessus pour commencer le lundi avant le premier cas et pour finir le lundi aprés le dernier cas.L’intervalle des étiquettes de date est spécifié manuellement par date_breaks = dans scale_x_date(), ou automatiquement par label = label_date_short() (paquet scales).L’intervalle des petites lignes verticales entre les étiquettes de date est spécifié par date_minor_breaks =.Nous utilisons closed = \"left\" dans le geom_histogram() pour nous assurer que les dates sont comptées dans les bonnes bins.expand = c(0,0) dans les échelles x et y supprime l’espace excédentaire de chaque côte des axes, ce qui garantit également que les étiquettes de date commencent à partir de la premiére barre.","code":"\n# ALIGNEMENT TOTAL DE LA SEMAINE DU LUNDI\n#############################\n# définir la séquence des pauses hebdomadaires\nweekly_breaks_central <- seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # lundi avant la premiére affaire\n      to = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # lundi aprés la derniére affaire\n      by = \"week\")    # les bins sont de 7 jours \n\n\nggplot(data = central_data) + \n  \n  # créer un histogramme : spécifier les points de rupture des bacs : commence le lundi avant le premier cas, se termine le lundi aprés le dernier cas\n  geom_histogram(\n    \n    # esthétique de la mapping\n    mapping = aes(x = date_onset), # colonne de date mappée sur l'axe des x\n    \n    # ruptures de la case de l'histogramme\n    breaks = weekly_breaks_central, # pauses des cases de l'histogramme définies précédemment\n    \n    closed = \"left\",  # compter les cas à partir du début du point d'bin\n\n    # barres\n    color = \"darkblue\", # couleur des lignes autour des barres\n    fill = \"lightblue\" # couleur de remplissage dans les barres\n  )+ \n    \n  # étiquettes de l'axe des x\n  scale_x_date(\n    expand = c(0,0), # suppression de l'espace excédentaire sur l'axe des x avant et aprés les barres de cas\n    date_breaks = \"4 weeks\", # les étiquettes de date et les principales lignes de grille verticales apparaissent toutes les 3 semaines du lundi\n    date_minor_breaks = \"week\", # les lignes verticales mineures apparaissent chaque lundi de semaine\n    #date_labels = \"%a\\n%d\\n%b\\n'%y\", # option de formatage manuel des étiquettes de date\n    label = scales::label_date_short())+ # format des étiquettes automatique\n  \n  # Axe des y\n  scale_y_continuous(\n    expand = c(0,0))+ # suppression de l'espace excédentaire sur l'axe des y en dessous de 0 (alignement de l'histogramme sur l'axe des x)\n  \n  # thèmes esthétiques\n  theme_minimal()+ # simplifie le fond du graphique\n  \n  theme(\n    plot.caption = element_text(hjust = 0, # légende sur le côte gauche\n                                face = \"italic\"), # légende en italique\n    axis.title = element_text(face = \"bold\"))+ # titres des axes en gras\n  \n  # étiquettes incluant une légende dynamique\n  labs(\n    title = \"Incidence hebdomadaire des cas (semaines de lundi)\",\n    subtitle = \"Notez l'alignement des barres, des lignes de grille verticales et des étiquettes d'axe sur les semaines du lundi\",\n    x = \"Semaine d'apparition des symptômes\",\n    y = \"Incidence hebdomadaire des cas signalés\",\n    caption = stringr::str_glue(\"n = {nrow(central_data)} de Central Hospital ; Les occurrences de cas ranges de {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} à {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}{nrow(central_data %>% filter(is.na(date_onset)))} cas dont la date d'apparition est manquante et qui ne sont pas indiqués\"))"},{"path":"epicurves.html","id":"semaines-de-dimanche","chapter":"1 Courbes épidémiques","heading":"Semaines de dimanche","text":"Pour obtenir le graphique ci-dessus pour les semaines de dimanche, quelques modifications sont nécessaires, car les date_breaks = \"weeks\" ne fonctionnent que pour les semaines de lundi.Les points de rupture des bins de l’histogramme doivent étre fixés au dimanche (week_start = 7)Dans scale_x_date(), les ruptures de date similaires doivent étre fournies à breaks = et minor_breaks = pour s’assurer que les étiquettes de date et les lignes de grille verticales s’alignent sur les dimanches.Par exemple, la commande scale_x_date() pour les semaines du dimanche pourrait ressembler à ceci :","code":"scale_x_date(\n    expand = c(0,0),\n    \n    # spécifie l'intervalle des étiquettes de date et des principales lignes de grille verticales\n    breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # dimanche avant la premiére affaire\n      to = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # dimanche aprés la derniére affaire\n      by = \"4 weeks\"),\n    \n    # spécifier l'intervalle de la ligne de grille verticale mineure \n    minor_breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # dimanche avant le premier cas\n      to = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # dimanche aprés la derniére affaire\n      by = \"week\"),\n   \n    # format des étiquettes de date\n    #date_labels = \"%a\\n%d\\n%b\\n'%y\", # option de formatage manuel des étiquettes de date.\n                                      # Jour, au-dessus abréviation du mois, au-dessus\n                                      # année à 2 chiffres\n    label = scales::label_date_short())+ # format des étiquettes automatique"},{"path":"epicurves.html","id":"groupercolorer-par-valeur","chapter":"1 Courbes épidémiques","heading":"Grouper/colorer par valeur","text":"Les barres de l’histogramme peuvent étre colorées par groupe et “empilées”. Pour désigner la colonne de regroupement, effectuez les modifications suivantes. Voir la page ggplot basics pour plus de détails.Dans le mappage esthétique de l’histogramme aes(), mettez en correspondance le nom de la colonne avec les arguments group = et fill =.Supprimez tout argument fill = à l’extérieur de aes(), car il remplacera celui qui se trouve à l’intérieur.Les arguments inside de aes() s’appliqueront par groupe, alors que les arguments outside s’appliqueront à toutes les barres (par exemple, vous pouvez toujours vouloir color = à l’extérieur, pour que chaque barre ait la même bordure).Voici à quoi ressemblerait la commande aes() pour grouper et colorer les barres par sexe :Le voici appliqué :","code":"\naes(x = date_onset, group = gender, fill = gender)\nggplot(data = linelist) + # commencer avec linelist (many hospitals)\n  \n  # faire un histogramme : spécifier les points de rupture de la benne : commence le lundi avant le premier cas, se termine le lundi aprés le dernier cas\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = hospital, # définir les données pour qu'elles soient groupées par hôpital\n      fill = hospital), # remplissage des barres (couleur intérieure) par hôpital\n    \n    # les pauses sont les semaines de lundi\n    breaks = weekly_breaks_all, # séquence de pauses hebdomadaires du lundi pour toute l'épidémie, définie dans le code précédent \n    \n    closed = \"left\", # Compter les cas à partir du début du point d'arrêt\n    \n    # Couleur autour des barres\n    color = \"black\")"},{"path":"epicurves.html","id":"ajuster-les-couleurs","chapter":"1 Courbes épidémiques","heading":"Ajuster les couleurs","text":"Pour manuellement régler le remplissage pour chaque groupe, utilisez scale_fill_manual() (note : scale_color_manual() est différent !).\nUtilisez l’argument values = pour appliquer un vecteur de couleurs.\nUtilisez na.value = pour spécifier une couleur pour les valeurs NA.\nUtilisez l’argument labels = pour changer le texte des éléments de la légende. Pour étre sur, fournissez un vecteur nommé comme c(\"old\" = \"new\", \"old\" = \"new\") ou ajustez les valeurs dans les données elles-mêmes.\nUtilisez name = pour donner un titre correct à la légende.\nUtilisez l’argument values = pour appliquer un vecteur de couleurs.Utilisez na.value = pour spécifier une couleur pour les valeurs NA.Utilisez l’argument labels = pour changer le texte des éléments de la légende. Pour étre sur, fournissez un vecteur nommé comme c(\"old\" = \"new\", \"old\" = \"new\") ou ajustez les valeurs dans les données elles-mêmes.Utilisez name = pour donner un titre correct à la légende.Pour plus d’informations sur les échelles et les palettes de couleurs, consultez la page sur les bases de ggplot.","code":"\nggplot(data = linelist)+ # commencer avec linelist (plusieurs hôpitaux)\n  \n  # faire un histogramme\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital, # cas groupés par hôpital\n        fill = hospital), # remplissage des barres par hôpital\n    \n    # bin breaks\n    breaks = weekly_breaks_all, # séquence de bin breaks hebdomadaires du lundi, définie dans le code précédent\n    \n    closed = \"left\", # Compter les cas à partir du début du point d'arrêt\n  \n    color = \"black\")+ # couleur de la bordure de chaque barre\n  \n  # spécification manuelle des couleurs\n  scale_fill_manual(\n    values = c(\"black\", \"orange\", \"grey\", \"beige\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St.Mark's\"),\n    name = \"Hospital\") # spécifier les couleurs de remplissage (\"values\") - attention à l'ordre !"},{"path":"epicurves.html","id":"ajuster-lordre-des-niveaux","chapter":"1 Courbes épidémiques","heading":"Ajuster l’ordre des niveaux","text":"Le meilleur moyen d’ajuster l’ordre dans lequel les barres groupées sont empilées est de classer la colonne de groupage en tant que classe Facteur. Vous pouvez alors désigner l’ordre des niveaux de facteurs (et leurs étiquettes d’affichage). Voir la page sur facteurs ou ggplot tips pour plus de détails.Avant de réaliser le tracé, utilisez la fonction fct_relevel() du paquet forcats pour convertir la colonne de regroupement en classe facteur et ajuster manuellement l’ordre des niveaux, comme détaillé dans la page sur les facteurs. Pour ajuster les niveaux de manière plus avancée, utilisez fct_lump(), qui combine automatiquement les petites catégories en une catégorie “Autre”.Dans le graphique ci-dessous, les seules différences par rapport au précédent sont que la colonne hospital été consolidée comme ci-dessus, et que nous utilisons guides() pour inverser l’ordre de la légende, de sorte que “Missing” se trouve en bas de la légende.TIP: Pour inverser l’ordre de la légende uniquement, ajoutez cette commande ggplot2 : guides(fill = guide_legend(reverse = TRUE)).","code":"\n# charger le paquet forcats pour travailler avec les facteurs\npacman::p_load(forcats)\n\n# définir un nouvel ensemble de données avec l'hôpital comme facteur\nplot_data <- linelist %>% \n  mutate(hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))) # Convertir en facteur et définir \"Manquant\" et \"Autre\" comme niveaux supérieurs pour apparaétre sur le sommet de l'épicurve.\n\nlevels(plot_data$hospital) # Imprime les niveaux dans l'ordre## [1] \"Missing\"                              \"Other\"                               \n## [3] \"Central Hospital\"                     \"Military Hospital\"                   \n## [5] \"Port Hospital\"                        \"St. Mark's Maternity Hospital (SMMH)\"\nggplot(plot_data) + # Utiliser le NOUVEL ensemble de données avec les hôpitaux comme facteurs réordonnés.\n  \n  # créer un histogramme\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital, # cas groupés par hôpital\n        fill = hospital), # remplissage des barres (couleur) par hôpital\n    \n    breaks = weekly_breaks_all, # séquence de pauses hebdomadaires du lundi pour toute l'épidémie, définie en haut de la section ggplot\n    \n    closed = \"left\", # Compter les cas à partir du début du point d'arrêt\n\n    color = \"black\")+ # couleur de la bordure autour de chaque barre\n    \n  # étiquettes de l'axe des x\n  scale_x_date(\n    expand = c(0,0), # supprimer l'espace excédentaire sur l'axe des x avant et aprés les barres de cas\n    date_breaks = \"3 weeks\", # les étiquettes apparaissent toutes les 3 semaines du lundi\n    date_minor_breaks = \"week\", # les lignes verticales apparaissent tous les lundis de la semaine\n    label = scales::label_date_short())+ # format des étiquettes de date efficace\n  \n  # Axe des y\n  scale_y_continuous(\n    expand = c(0,0))+ # suppression de l'espace excédentaire sur l'axe des y en dessous de 0\n  \n  # spécification manuelle des couleurs, ! attention à l'ordre\n  scale_fill_manual(\n    values = c(\"grey\", \"beige\", \"black\", \"orange\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St.Marks\"),\n    name = \"Hospital\")+ \n  \n  # thèmes esthétiques\n  theme_minimal()+ # simplifier le fond du graphique\n  \n  theme(\n    plot.caption = element_text(face = \"italic\", # légende à gauche en italique\n                                hjust = 0), \n    axis.title = element_text(face = \"bold\"))+ # titres des axes en gras\n  \n  # étiquettes\n  labs(\n    title = \"Incidence hebdomadaire des cas par hôpital\",\n    subtitle = \"Hospital as re-ordered factor\",\n    x = \"Semaine d'apparition des symptômes\",\n    y = \"Cas hebdomadaires\")"},{"path":"epicurves.html","id":"ajuster-la-légende","chapter":"1 Courbes épidémiques","heading":"Ajuster la légende","text":"Pour en savoir plus sur les légendes et les échelles, consultez la page ggplot tips. Voici quelques points saillants :Modifiez le titre de la légende soit dans la fonction d’échelle, soit avec labs(fill = \"Legend title\") (si vous utilisez color = esthétique, alors utilisez labs(color = \"\")).theme(legend.title = element_blank()) pour ne pas avoir de titre de légendetheme(legend.position = \"top\") (“bottom”, “left”, “right”, ou “none” pour supprimer la légende)theme(legend.direction = \"horizontal\") légende horizontaleguides(fill = guide_legend(reverse = TRUE)) pour inverser l’ordre de la légende","code":""},{"path":"epicurves.html","id":"barres-côte-à-côte","chapter":"1 Courbes épidémiques","heading":"Barres côte à côte","text":"L’affichage côte à côte des barres de groupe (par opposition à l’empilement) est spécifié dans geom_histogram() avec position = \"dodge\" placé en dehors de aes().S’il y plus de deux groupes de valeurs, ceux-ci peuvent devenir difficiles à lire. Envisagez plutôt d’utiliser un graphique à facettes (petits multiples). Pour améliorer la lisibilité dans cet exemple, les valeurs de sexe manquantes sont supprimées.","code":"\nggplot(central_data %>% drop_na(gender))+ # Commencez par les cas de l'hôpital central en supprimant les valeurs manquantes pour le sexe.\n    geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = gender, # cas groupés par sexe\n          fill = gender), # barres remplies par sexe\n        \n        # histogramme bin breaks\n        breaks = weekly_breaks_central, # séquence de dates hebdomadaires pour le foyer central - définie en haut de la section ggplot\n        \n        closed = \"left\",\n        \n        color = \"black\", # couleur du bord des barres\n        \n        position = \"dodge\")+ # barres SIDE-BY-SIDE\n                      \n  \n  # Les étiquettes sur l'axe des x\n  scale_x_date(\n       expand = c(0,0), # supprimer l'espace excédentaire de l'axe des x sous et aprés les barres de cas\n       date_breaks = \"3 weeks\", # les étiquettes apparaissent toutes les 3 semaines du lundi\n       date_minor_breaks = \"week\", # les lignes verticales apparaissent tous les lundis de la semaine\n       label = scales::label_date_short())+ # format des étiquettes de date efficace\n\n  \n  # Axe des y\n  scale_y_continuous(expand = c(0,0))+ # supprime l'espace excédentaire sur l'axe des y entre le bas des barres et les étiquettes\n  \n  #échelle des couleurs et des étiquettes de légende\n  scale_fill_manual(values = c(\"brown\", \"orange\"), # spécifie les couleurs de remplissage (\"values\") - attention à l'ordre !\n                    na.value = \"grey\" )+     \n\n  # thèmes esthétiques\n  theme_minimal()+ # un ensemble de thèmes pour simplifier le graphe\n  theme(plot.caption = element_text(face = \"italic\", hjust = 0), # légende à gauche en italique\n        axis.title = element_text(face = \"bold\"))+ # titres des axes en gras\n  \n  # étiquettes\n  labs(title = \"Incidence hebdomadaire des cas, par sexe\",\n       subtitle = \"Sous-titre\",\n       fill = \"Gender\", # fournir un nouveau titre pour la légende\n       x = \"Semaine d'apparition des symptômes\",\n       y = \"Incidence hebdomadaire des cas signalés\")"},{"path":"epicurves.html","id":"limites-de-laxe","chapter":"1 Courbes épidémiques","heading":"Limites de l’axe","text":"Il existe deux façons de limiter l’étendue des valeurs des axes.Généralement, la méthode préférée est d’utiliser la commande coord_cartesian(), qui accepte xlim = c(min, max) et ylim = c(min, max) (où vous fournissez les valeurs min et max). Ceci agit comme un “zoom” sans réellement supprimer de données, ce qui est important pour les statistiques et les mesures sommaires.Alternativement, vous pouvez définir les valeurs maximales et minimales de la date en utilisant limits = c() dans scale_x_date(). Par exemple :Si vous souhaitez que l’axe des abscisses s’tende jusqu’é une date spécifique (par exemple, la date du jour), même si aucun nouveau cas n’été signalé, vous pouvez utiliser :DANGER: Soyez prudent en fixant les ruptures d’échelle ou les limites de l’axe des y (par exemple, 0 à 30 par 5 : seq(0, 30, 5)). De tels nombres statiques peuvent couper votre tracé trop court si les données changent pour dépasser la limite !.","code":"\nscale_x_date(limits = c(as.Date(\"2014-04-01\"), NA)) # définit une date minimum mais laisse la date maximum ouverte.  \nscale_x_date(limits = c(NA, Sys.Date())) # garantit que l'axe des dates s'étendra jusqu'à la date du jour  "},{"path":"epicurves.html","id":"libellés-des-axes-de-date-lignes-de-grille","chapter":"1 Courbes épidémiques","heading":"Libellés des axes de date / lignes de grille","text":"TIP: Rappelez-vous que les étiquettes de l’axe des dates sont indépendantes de l’agrégation des données en barres, mais visuellement, il peut étre important d’aligner les bacs, les étiquettes de date et les lignes de grille verticales.Pour modifier les étiquettes de date et les lignes de grille, utilisez scale_x_date() de l’une de ces façons :Si vos bins d’histogramme sont des jours, lundi des semaines, des mois ou des années :\nUtilisez date_breaks = pour spécifier l’intervalle des étiquettes et des lignes de grille principales (par exemple “jour”, “semaine”, “3 semaines”, “mois” ou “année”).\nUtilisez date_minor_breaks = pour spécifier l’intervalle des lignes verticales mineures (entre les étiquettes de date)\nAjoutez expand = c(0,0) pour que les étiquettes commencent à la premiére barre.\nUtilisez date_labels = pour spécifier le format des étiquettes de date avec la syntaxe strptime - voir la page Dates pour des conseils (e.g. utilisez \\n pour une nouvelle ligne), OU utilisez label = label_date_short() (du paquet scales) pour des étiquettes de date automatiques et efficaces.\nSi les cases de votre histogramme sont des semaines de dimanche :\nUtilisez breaks = et minor_breaks = en fournissant une séquence de ruptures de date pour chacun d’entre eux.\nVous pouvez toujours utiliser date_labels = et expand = pour le formatage comme décrit ci-dessus.\nUtilisez date_breaks = pour spécifier l’intervalle des étiquettes et des lignes de grille principales (par exemple “jour”, “semaine”, “3 semaines”, “mois” ou “année”).Utilisez date_minor_breaks = pour spécifier l’intervalle des lignes verticales mineures (entre les étiquettes de date)Ajoutez expand = c(0,0) pour que les étiquettes commencent à la premiére barre.Utilisez date_labels = pour spécifier le format des étiquettes de date avec la syntaxe strptime - voir la page Dates pour des conseils (e.g. utilisez \\n pour une nouvelle ligne), OU utilisez label = label_date_short() (du paquet scales) pour des étiquettes de date automatiques et efficaces.Si les cases de votre histogramme sont des semaines de dimanche :Utilisez breaks = et minor_breaks = en fournissant une séquence de ruptures de date pour chacun d’entre eux.Vous pouvez toujours utiliser date_labels = et expand = pour le formatage comme décrit ci-dessus.Quelques notes :Voir la section ggplot d’ouverture pour des instructions sur la façon de créer une séquence de dates en utilisant seq.Date().Voir cette page ou la page travailler avec des dates pour des conseils sur la création d’étiquettes de date.","code":""},{"path":"epicurves.html","id":"démonstrations","chapter":"1 Courbes épidémiques","heading":"Démonstrations","text":"Vous trouverez ci-dessous une démonstration de tracés où les bacs et les étiquettes/grilles sont alignés et non alignés :","code":"\n# Bacs de 7 jours + étiquettes du lundi\n#############################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7, # bins de 7 jours avec début au premier cas\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0), # supprime l'espace excédentaire sur l'axe des x en dessous et aprés les barres de cas\n    date_breaks = \"3 weeks\", # Lundi toutes les 3 semaines\n    date_minor_breaks = \"week\", # lundi semaines\n    \n    #date_labels = \"%a\\n%d\\n%b\\n'%y\", # option de formatage manuel des étiquettes de date\n    label = scales::label_date_short())+ # format des étiquettes automatique\n  \n  scale_y_continuous(\n    expand = c(0,0))+ # suppression de l'espace excédentaire sous l'axe des x, mise à plat\n  \n  labs(\n    title = \"MAL ALIGNÉ\",\n    subtitle = \" ! ATTENTION : Les barres de 7 jours commencent le jeudi avec le premier cas.\\n Grandes lignes de grille et étiquettes de date au 1er de chaque mois.\\n Lignes de grille mineures chaque lundi.\")\n\n\n\n# Tranches de 7 jours + Mois\n#####################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0), # supprime l'espace excédentaire de l'axe des x sous et aprés les barres de cas\n    date_breaks = \"months\", # 1er du mois\n    date_minor_breaks = \"week\", # semaines de lundi\n    label = scales::label_date_short())+ # format des étiquettes automatique\n  \n  scale_y_continuous(\n    expand = c(0,0)) + # Suppression de l'espace excédentaire sous l'axe des x, mise à plat des données \n  \n  labs(\n    title = \"MAL ALIGNÉ\",\n    subtitle = \" ! ATTENTION : Les barres de 7 jours commencent le jeudi avec le premier cas\\nLes lignes de grille principales et les étiquettes de date au 1er de chaque mois\\nLes lignes de grille mineures sont hebdomadaires le lundi\\nNotez l'espacement inégal de certaines lignes de grille et les tics non alignés avec les barres\"\n    )\n\n\n# ALIGNEMENT TOTAL DU LUNDI : spécifier que les pauses manuelles sont des lundis\n#################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # les ruptures d'histogramme sont fixées à 7 jours commençant le lundi avant le premier cas\n    breaks = weekly_breaks_central, # défini plus tôt dans cette page\n    \n    closed = \"left\",\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0), # supprime l'espace excédentaire sur l'axe x en dessous et aprés les barres de cas\n    date_breaks = \"4 weeks\", # Lundi toutes les 4 semaines\n    date_minor_breaks = \"week\", # lundi semaines \n    label = scales::label_date_short())+ # format des étiquettes automatique\n  \n  scale_y_continuous(\n    expand = c(0,0))+ # Suppression de l'espace excédentaire sous l'axe des x, mise à plat des données \n  \n  labs(\n    title = \"Lundis ALIGNÉS\",\n    subtitle = \"Les intervalles de 7 jours sont réglés manuellement pour commencer le lundi avant le premier cas (28 avr.)\\n Les étiquettes de date et les lignes de grille sont aussi sur les lundis\")\n\n\n# ALIGNEMENT TOTAL DES LUNDIS AVEC LES étiQUETTES DE MOIS :\n############################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # ruptures d'histogramme fixées à 7 jours commençant le lundi avant le premier cas\n    breaks = weekly_breaks_central, # défini plus tôt dans cette page\n    \n    color = \"darkblue\",\n    \n    closed = \"left\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0), # supprime l'espace excédentaire sur l'axe x en dessous et aprés les barres de cas\n    date_breaks = \"months\", # Lundi toutes les 4 semaines\n    date_minor_breaks = \"week\", # lundi semaines \n    label = scales::label_date_short())+ # format des étiquettes automatique\n  \n  scale_y_continuous(\n    expand = c(0,0))+ # suppression de l'espace excédentaire sous l'axe des x, mise à plat \n  \n  theme(panel.grid.major = element_blank())+ # Suppression des lignes de grille principales (tombent le 1er du mois)\n          \n  labs(\n    title = \"Lundis ALIGNÉS avec étiquettes MONTHLY\",\n    subtitle = \"Bacs de 7 jours réglés manuellement pour commencer le lundi avant le premier cas (28 avril) - étiquettes de date le 1er du mois - Suppression des principaux quadrillages mensuels\")\n\n\n# ALIGNEMENT TOTAL DU DIMANCHE : spécifier les ruptures manuelles des bacs ET les étiquettes pour les dimanches\n############################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # ruptures d'histogramme fixées à 7 jours commençant le dimanche avant le premier cas\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      to = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by = \"7 days\"),\n    \n    color = \"darkblue\",\n    \n    closed = \"left\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),\n    # les ruptures de l'étiquette de date et les principales lignes de la grille sont fixées à toutes les 3 semaines, en commençant le dimanche avant le premier cas.\n    breaks = seq.Date(\n         from = floor_date(min(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n         to = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n         by = \"3 weeks\"),\n    \n    # grilles mineures fixées à la semaine commençant le dimanche avant le premier cas\n    minor_breaks = seq.Date(\n         from = floor_date(min(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n         to = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n         by = \"7 days\"),\n    \n    label = scales::label_date_short())+ # format des étiquettes automatique\n  \n  scale_y_continuous(\n    expand = c(0,0))+ # suppression de l'espace excédentaire sous l'axe des x, mise à plat \n  \n  labs(title = \"Dimanches ALIGNÉS\",\n       subtitle = \"Les intervalles de 7 jours ont été réglés manuellement pour commencer le dimanche avant le premier cas (27 avril)\\n Les étiquettes de date et les lignes de grille ont également été réglées manuellement sur les dimanches\")"},{"path":"epicurves.html","id":"données-agrégées","chapter":"1 Courbes épidémiques","heading":"Données agrégées","text":"Souvent, au lieu d’une liste de lignes, vous commencez par des comptages agrégés d’établissements, de districts, etc. Vous pouvez faire une épicurve avec ggplot() mais le code sera légérement différent. Cette section va utiliser le jeu de données count_data qui été importé plus tôt, dans la section de préparation des données. Ce jeu de données est la linelist agrégée au nombre de jours d’hospitalisation. Les 50 premiéres lignes sont affichôes ci-dessous.","code":""},{"path":"epicurves.html","id":"tracer-des-épicentres-quotidiens","chapter":"1 Courbes épidémiques","heading":"Tracer des épicentres quotidiens","text":"Nous pouvons tracer une épicurve quotidienne à partir de ces comptes quotidiens. Voici les différences par rapport au code :Dans le mappage esthétique aes(), spécifiez y = comme colonne de comptage (dans ce cas, le nom de la colonne est n_cases).Ajoutez l’argument stat = \"identity\" dans geom_histogram(), qui spécifie que la hauteur de la barre doit étre la valeur y =, et non le nombre de lignes comme c’est le cas par défaut.Ajoutez l’argument width = pour éviter les lignes blanches verticales entre les barres. Pour les données quotidiennes, fixez la valeur à 1. Pour les données de comptage hebdomadaire, fixez la valeur à 7. Pour les données de comptage mensuel, les lignes blanches sont un probléme (chaque mois un nombre de jours différent) - envisagez de transformer votre axe des x en un facteur ordonné catégorique (mois) et utilisez `geom_col()``.","code":"\nggplot(data = count_data) +\n  geom_histogram(\n    mapping = aes(x = date_hospitalisation, y = n_cases),\n    stat = \"identity\",\n    width = 1) + # pour les comptages quotidiens, définir width = 1 pour éviter les espaces blancs entre les barres\n  labs(\n    x = \"Date du rapport\", \n    y = \"Nombre de cas\",\n    title = \"Incidence quotidienne des cas, à partir des données de comptage quotidiennes\")"},{"path":"epicurves.html","id":"tracer-les-comptages-hebdomadaires","chapter":"1 Courbes épidémiques","heading":"Tracer les comptages hebdomadaires","text":"Si vos données sont déjà des comptages de cas par semaine, elles peuvent ressembler à cet ensemble de données (appelé count_data_weekly) :Les 50 premiéres lignes de count_data_weekly sont affichées ci-dessous. Vous pouvez voir que les comptes ont été agrégés en semaines. Chaque semaine est affichée par le premier jour de la semaine (lundi par défaut).Maintenant, tracez le graphique de façon à ce que x = la colonne epiweek. N’oubliez pas d’ajouter y = la colonne des comptes à la mapping esthétique, et ajoutez stat = \"identity\" comme expliqué ci-dessus.","code":"\nggplot(data = count_data_weekly)+\n  \n  geom_histogram(\n    mapping = aes(\n      x = epiweek, # l'axe des x est l'epiweek (en tant que classe Date)\n      y = n_cases_weekly, # l'axe des y est la hauteur du nombre de cas hebdomadaires\n      group = hospital, # nous regroupons les barres et les couleurs par hôpital\n      fill = hospital),\n    stat = \"identity\")+ # ceci est également nécessaire lorsque l'on trace des données de comptage\n     \n  # étiquettes pour l'axe des x\n  scale_x_date(\n    date_breaks = \"2 months\", # étiquettes tous les 2 mois \n    date_minor_breaks = \"1 month\", # grilles tous les mois\n    label = scales::label_date_short())+ # format des étiquettes automatique\n     \n  # Choisissez la palette de couleurs (utilise le paquet RColorBrewer)\n  scale_fill_brewer(palette = \"Pastel2\")+ \n  \n  theme_minimal()+\n  \n  labs(\n    x = \"Semaine d'apparition\", \n    y = \"Incidence hebdomadaire des cas\",\n    fill = \"Hospital\",\n    title = \"Incidence hebdomadaire des cas, à partir des données de comptage agrégées par hôpital\")"},{"path":"epicurves.html","id":"moyennes-mobiles","chapter":"1 Courbes épidémiques","heading":"Moyennes mobiles","text":"Voir la page sur les Moyennes mobiles pour une description détaillée et plusieurs options. Vous trouverez ci-dessous une option pour calculer des moyennes mobiles avec le package slider. Dans cette approche, la moyenne mobile est calculée dans l’ensemble de données avant le tracé :Regroupez les données en comptes si nécessaire (quotidien, hebdomadaire, etc.) (voir la page sur groupage des données).créez une nouvelle colonne pour contenir la moyenne mobile, créée avec slide_index() du paquet slider.Tracez la moyenne mobile comme une geom_line() au-dessus (aprés) l’histogramme épicurvienVoir l’utile vignette pour le paquet slider","code":"\n# charger le paquet\npacman::p_load(slider) # slider utilisé pour calculer les moyennes mobiles\n\n# créer un jeu de données de comptages quotidiens et de moyennes mobiles sur 7 jours\n#######################################################\nll_counts_7day <- linelist %>% # commencer avec linelist\n  \n  ## compter les cas par date\n  count(date_onset, name = \"new_cases\") %>% # nommer une nouvelle colonne avec les comptages comme \"new_cases\".\n  drop_na(date_onset) %>% # supprime les cas dont la date_onset est manquante\n  \n  ## calculer le nombre moyen de cas dans la fenétre de 7 jours\n  mutate(\n    avg_7day = slider::slide_index( # créer une nouvelle colonne\n      new_cases, # calcul basé sur la valeur de la colonne new_cases\n      .i = date_onset, # l'index est la colonne date_onset, donc les dates non présentes sont incluses dans la fenétre \n      .f = ~mean(.x, na.rm = TRUE), # La fonction est mean() avec les valeurs manquantes supprimées.\n      .before = 6, # la fenétre est le jour et les 6 jours précédents\n      .complete = FALSE), # doit étre FALSE pour que unlist() fonctionne à l'étape suivante\n    avg_7day = unlist(avg_7day)) # convertit la liste des classes en classes numériques\n\n\n# tracer\n######\nggplot(data = ll_counts_7day) + # commencer avec le nouvel ensemble de données défini ci-dessus \n    geom_histogram( # crée un histogramme épicurve\n      mapping = aes(\n        x = date_onset, # colonne de date comme axe des x\n        y = new_cases), # la hauteur est le nombre de nouveaux cas quotidiens\n        stat = \"identity\", # la hauteur est la valeur y\n        fill=\"#92a8d1\", # couleur froide pour les barres\n        colour = \"#92a8d1\", # même couleur pour la bordure des barres\n        )+ \n    geom_line( # créer une ligne pour la moyenne mobile\n      mapping = aes(\n        x = date_onset, # colonne de date pour l'axe des x\n        y = avg_7day, # valeur y définie dans la colonne de la moyenne mobile\n        lty = \"7-day \\nrolling avg\"), # nom de la ligne dans la légende\n      color=\"red\", # couleur de la ligne\n      size = 1) + # largeur de la ligne\n    scale_x_date( # échelle de date\n      date_breaks = \"1 month\",\n      label = scales::label_date_short(), # format des étiquettes automatique\n      expand = c(0,0)) +\n    scale_y_continuous( # échelle de l'axe des y\n      expand = c(0,0),\n      limits = c(0, NA)) +       \n    labs(\n      x=\"\",\n      y = \"Nombre de cas confirmés\",\n      fill = \"Legende\")+ \n    theme_minimal()+\n    theme(legend.title = element_blank()) # supprime le titre de la légende"},{"path":"epicurves.html","id":"facettespetits-multiples","chapter":"1 Courbes épidémiques","heading":"Facettes/petits-multiples","text":"Comme pour les autres ggplots, vous pouvez créer des graphiques à facettes (“petits multiples”). Comme expliqué dans la page ggplot tips de ce manuel, vous pouvez utiliser soit facet_wrap() soit facet_grid(). Ici, nous faisons une démonstration avec facet_wrap(). Pour les épicurves, facet_wrap() est typiquement plus facile car il est probable que vous n’ayez besoin de faire une facette que sur une seule colonne.La syntaxe générale est facet_wrap(rows ~ cols), où à gauche du tilde (~) est le nom d’une colonne à répartir sur les “rows” du graphique à facettes, et à droite du tilde est le nom d’une colonne à répartir sur les “columns” du graphique à facettes. Plus simplement, il suffit d’utiliser un seul nom de colonne, à droite du tilde : facet_wrap(~age_cat).Axes libres\nVous devrez décider si les échelles des axes pour chaque facette sont “fixées” aux mêmes dimensions (par défaut), ou “libres” (ce qui signifie qu’elles changeront en fonction des données de la facette). Faites-le avec l’argument scales = dans facet_wrap() en spécifiant “free_x” ou “free_y”, ou “free”.Nombre de cols et de rangs de facettes\nCela peut étre spécifié avec ncol = et nrow = dans facet_wrap().Ordre des facettes\nPour changer l’ordre d’apparition, changez l’ordre sous-jacent des niveaux de la colonne de facteurs utilisée pour créer les facettes.esthétique\nLa taille et le visage de la police, la couleur de la bande, etc. peuvent étre modifiés par theme() avec des arguments comme :strip.text = element_text() (taille, couleur, face, angle…)strip.background = element_rect() (par exemple element_rect(fill=“grey”))strip.position = (position de la bande “bas”, “haut”, “gauche” ou “droite”)Libellés des bandes\nLes étiquettes des graphiques à facettes peuvent étre modifiées par les “étiquettes” de la colonne comme facteur, ou par l’utilisation d’un “labeller”.Faites une étiquette comme celle-ci, en utilisant la fonction as_labeller() de ggplot2. Puis fournissez l’étiqueteuse à l’argument labeller = de facet_wrap() comme indiqué ci-dessous.Un exemple de graphique à facettes - facetté par la colonne age_cat.Voir ce lien pour plus d’informations sur les étiqueteuses.","code":"\nmy_labels <- as_labeller(c(\n     \"0-4\" = \"0-4 ans\",\n     \"5-9\" = \"5-9 ans\",\n     \"10-14\" = \"10-14 ans\",\n     \"15-19\" = \"15-19 ans\",\n     \"20-29\" = \"20-29 ans\",\n     \"30-49\" = \"30-49 ans\",\n     \"50-69\" = \"50-69 ans\",\n     \"70+\" = \"Plus de 70 ans\"))\n# faire le graphe\n###########\nggplot(central_data) + \n  \n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat), # les arguments à l'intérieur de aes() s'appliquent par groupe\n      \n    color = \"black\", # les arguments hors aes() s'appliquent à toutes les données\n        \n    # ruptures d'histogramme\n    breaks = weekly_breaks_central,\n    closed = \"left\")+ # vecteur de date prédéfini (voir plus haut dans cette page)\n                      \n  # Les étiquettes sur l'axe des x\n  scale_x_date(\n    expand = c(0,0), # supprimez l'espace excédentaire sur l'axe des x en dessous et aprés les barres de cas\n    date_breaks = \"2 months\", # les étiquettes apparaissent tous les 2 mois\n    date_minor_breaks = \"1 month\", # les lignes verticales apparaissent tous les 1 mois \n    label = scales::label_date_short())+ # format des étiquettes automatique\n  \n  # Axe des y\n  scale_y_continuous(expand = c(0,0))+ # supprime l'espace excédentaire sur l'axe des y entre le bas des barres et les étiquettes\n  \n  # thèmes esthétiques\n  theme_minimal()+ # un ensemble de thèmes pour simplifier le graphique\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # légende à gauche en italique\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"grey\"))+ # titres des axes en gras\n  \n  # créer des facettes\n  facet_wrap(\n    ~age_cat,\n    ncol = 4,\n    strip.position = \"top\",\n    labeller = my_labels)+             \n  \n  # étiquettes\n  labs(\n    title = \"Incidence hebdomadaire des cas, par catégorie d'âge\",\n    subtitle = \"Sous-titre\",\n    fill = \"Catégorie d'âge\", # fournir un nouveau titre pour la légende\n    x = \"Semaine d'apparition des symptômes\",\n    y = \"Cas incidents hebdomadaires signalés\",\n    caption = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital ; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} à {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}{nrow(central_data %>% filter(is.na(date_onset)))} cas dont la date d'apparition est manquante et qui ne sont pas indiqués\"))"},{"path":"epicurves.html","id":"épidémie-totale-dans-larriére-plan-de-la-facette","chapter":"1 Courbes épidémiques","heading":"1.2.0.1 Épidémie totale dans l’arriére-plan de la facette","text":"Pour afficher l’épidémie totale en arriére-plan de chaque facette, ajoutez la fonction gghighlight() avec des parenthôses vides au ggplot. Cette fonction provient du paquet gghighlight. Notez que le maximum de l’axe des y dans toutes les facettes est maintenant basé sur le pic de l’épidémie entiére. Il y plus d’exemples de ce package dans la page ggplot tips.","code":"\nggplot(central_data) + \n  \n  # Epicurves par groupe\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat), # les arguments à l'intérieur de aes() s'appliquent par groupe\n    \n    color = \"black\", # les arguments hors aes() s'appliquent à toutes les données\n    \n    # ruptures d'histogramme\n    breaks = weekly_breaks_central,\n    closed = \"left\")+ # vecteur de dates prédéfini (voir en haut de la section ggplot)                \n  \n  # ajoute une épidémie grise en arriére-plan à chaque facette\n  gghighlight::gghighlight()+\n  \n  # étiquettes sur l'axe des x\n  scale_x_date(\n    expand = c(0,0), # Suppression de l'espace excédentaire sur l'axe des x sous et aprés les barres de cas\n    date_breaks = \"2 months\", # les étiquettes apparaissent tous les 2 mois\n    date_minor_breaks = \"1 month\", # les lignes verticales apparaissent tous les 1 mois \n    label = scales::label_date_short())+ # format des étiquettes automatique\n  \n  # Axe des y\n  scale_y_continuous(expand = c(0,0))+ # supprime l'espace excédentaire de l'axe des y en dessous de 0\n  \n  # thèmes esthétiques\n  theme_minimal()+ # un ensemble de thèmes pour simplifier le graphique\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # légende à gauche en italique\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"white\"))+ # titres des axes en gras\n  \n  # créer des facettes\n  facet_wrap(\n    ~age_cat, # chaque facette est une valeur de age_cat\n    ncol = 4, # nombre de colonnes\n    strip.position = \"top\", # position du titre/strip de la facette\n    labeller = my_labels)+ # labeller définit ci-dessus\n  \n  # étiquettes\n  labs(\n    title = \"Incidence hebdomadaire des cas, par catégorie d'âge\",\n    subtitle = \"Sous-titre\",\n    fill = \"Catégorie d'âge\", # fournit un nouveau titre pour la légende\n    x = \"Semaine d'apparition des symptômes\",\n    y = \"Cas incidents hebdomadaires signalés\",\n    caption = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital ; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} à {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}{nrow(central_data %>% filter(is.na(date_onset)))} cas dont la date d'apparition est manquante et qui ne sont pas indiqués\"))"},{"path":"epicurves.html","id":"une-facette-avec-des-données","chapter":"1 Courbes épidémiques","heading":"Une facette avec des données","text":"Si vous voulez avoir une seule boîte à facettes qui contient toutes les données, dupliquez l’ensemble des données et traitez les doublons comme une seule valeur de facette. La fonction “helper” CreateAllFacet() ci-dessous peut vous aider (gràce à cet article de blog). Quand elle est exécutée, le nombre de lignes double et il y aura une nouvelle colonne appelée facet dans laquelle les lignes dupliquées auront la valeur “”, et les lignes originales auront la valeur originale de la colonne de facettes. Il ne vous reste plus qu’à effectuer la facette sur la colonne facet.Voici la fonction d’aide. Exécutez-la pour qu’elle soit disponible pour vous.Appliquez maintenant la fonction d’aide à l’ensemble de données, sur la colonne age_cat :Les changements notables de la commande ggplot() sont les suivants :Les données utilisées sont maintenant central_data2 (deux fois plus de lignes, avec une nouvelle colonne “facet”).L’étiqueteuse devra étre mise à jour, si elle est utilisée.Optionnel : pour obtenir des facettes empilées verticalement : la colonne facette est déplacée vers les lignes de l’équation et remplacée à droite par “.” (facet_wrap(facet~.)), et ncol = 1. Vous pouvez aussi avoir besoin d’ajuster la largeur et la hauteur de l’image du graphique en png (voir ggsave() dans ggplot tips).","code":"\n# définir la fonction d'aide\nCreateAllFacet <- function(df, col){\n     df$facet <- df[[col]]\n     temp <- df\n     temp$facet <- \"all\"\n     merged <-rbind(temp, df)\n     \n     # s'assurer que la valeur de la facette est un facteur\n     merged[[col]] <- as.factor(merged[[col]])\n     \n     return(merged)\n}\n# créez un jeu de données dupliqué et avec une nouvelle colonne \"facet\" pour afficher \"toutes\" les catégories d'âge comme autre niveau de facette.\ncentral_data2 <- CreateAllFacet(central_data, col = \"age_cat\") %>%\n  \n  # définir les niveaux de facteurs\n  mutate(facet = fct_relevel(facet, \"all\", \"0-4\", \"5-9\",\n                             \"10-14\", \"15-19\", \"20-29\",\n                             \"30-49\", \"50-69\", \"70+\"))## Warning: There was 1 warning in `mutate()`.\n## ℹ In argument: `facet = fct_relevel(...)`.\n## Caused by warning:\n## ! 1 unknown level in `f`: 70+\n# vérifier les niveaux\ntable(central_data2$facet, useNA = \"always\")## \n##   all   0-4   5-9 10-14 15-19 20-29 30-49 50-69  <NA> \n##   454    84    84    82    58    73    57     7     9\nggplot(central_data2) + \n  \n  # Epicurves réelles par groupe\n  geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = age_cat,\n          fill = age_cat), # les arguments à l'intérieur de aes() s'appliquent par groupe\n        color = \"black\", # les arguments hors aes() s'appliquent à toutes les données\n        \n        # ruptures d'histogramme\n        breaks = weekly_breaks_central, # vecteur de dates prédéfini (voir en haut de la section ggplot)\n        closed = \"left\")+ \n                     \n  # étiquettes sur l'axe des x\n  scale_x_date(\n    expand = c(0,0), # supprime l'espace excédentaire de l'axe des x sous et aprés les barres de cas\n    date_breaks = \"2 months\", # les étiquettes apparaissent tous les 2 mois\n    date_minor_breaks = \"1 month\", # les lignes verticales apparaissent tous les 1 mois \n    label = scales::label_date_short())+ # format des étiquettes automatique\n  \n  # Axe des y\n  scale_y_continuous(expand = c(0,0))+ # supprime l'espace excédentaire sur l'axe des y entre le bas des barres et les étiquettes\n  \n  # thèmes esthétiques\n  theme_minimal()+ # un ensemble de thèmes pour simplifier le graphique\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # légende à gauche en italique\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\")+               \n  \n  # créer des facettes\n  facet_wrap(facet~. , # chaque parcelle est une valeur de la facette\n             ncol = 1)+            \n\n  # étiquettes\n  labs(title = \"Incidence hebdomadaire des cas, par catégorie d'âge\",\n       subtitle = \"Sous-titre\",\n       fill = \"Catégorie d'âge\", # fournit un nouveau titre pour la légende\n       x = \"Semaine d'apparition des symptômes\",\n       y = \"Cas incidents hebdomadaires signalés\",\n       caption = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital ; Case onsets range from\n                                   {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} à\n                                   {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cas dont la date d'apparition est manquante et qui ne sont pas indiqués\"))"},{"path":"epicurves.html","id":"données-provisoires","chapter":"1 Courbes épidémiques","heading":"1.3 Données provisoires","text":"Les données les plus récentes présentées dans les épicurves doivent souvent étre marquées comme provisoires, ou sujettes à des retards de déclaration. Ceci peut étre fait en ajoutant une ligne verticale et/ou un rectangle sur un nombre de jours spécifié. Voici deux options :Utilisez annotate() :\nPour une ligne, utilisez annotate(geom = \"segment\"). Fournissez x, xend, y, et yend. Ajustez la taille, le type de ligne (lty) et la couleur.\nPour un rectangle, utilisez annotate(geom = \"rect\"). Fournissez xmin/xmax/ymin/ymax. Ajustez la couleur et l’alpha.\nPour une ligne, utilisez annotate(geom = \"segment\"). Fournissez x, xend, y, et yend. Ajustez la taille, le type de ligne (lty) et la couleur.Pour un rectangle, utilisez annotate(geom = \"rect\"). Fournissez xmin/xmax/ymin/ymax. Ajustez la couleur et l’alpha.Regroupez les données par statut provisoire et colorez ces barres différemment.CAUTION: Vous pourriez essayer geom_rect() pour dessiner un rectangle, mais l’ajustement de la transparence ne fonctionne pas dans un contexte de linelist. Cette fonction superpose un rectangle pour chaque observation/rangée ! Utilisez soit un alpha trés faible (par exemple 0,01), soit une autre approche. ","code":""},{"path":"epicurves.html","id":"utilisation-de-annotate","chapter":"1 Courbes épidémiques","heading":"Utilisation de annotate()","text":"Dans annotate(geom = \"rect\"), les arguments xmin et xmax doivent recevoir des entrées de la classe Date.Notez que, comme ces données sont agrégées en barres hebdomadaires et que la derniére barre s’étend jusqu’au lundi suivant le dernier point de données, la région ombrée peut sembler couvrir 4 semaines.Voici un annotate() exemple en ligneLa même ligne verticale noire peut étre obtenue avec le code ci-dessous, mais en utilisant geom_vline() vous perdez la possibilité de contrôler la hauteur :","code":"\nggplot(central_data) + \n  \n  # histogramme\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    breaks = weekly_breaks_central, # vecteur de date prédéfini - voir en haut de la section ggplot\n    \n    color = \"darkblue\",\n    \n    closed = \"left\",\n    \n    fill = \"lightblue\") +\n\n  # échelles\n  scale_y_continuous(expand = c(0,0))+\n  scale_x_date(\n    expand = c(0,0), # Suppression de l'espace excédentaire sur l'axe des x sous et aprés les barres de cas\n    date_breaks = \"1 month\", # 1er du mois\n    date_minor_breaks = \"1 month\", # 1er du mois\n    label = scales::label_date_short())+ # format des étiquettes automatique\n  \n  # étiquettes et theme\n  labs(\n    title = \"Utilisant annotate()\\nRectangle et ligne montrant que les données des 21 derniers jours sont provisoires\",\n    x = \"Semaine d'apparition des symptômes\",\n    y = \"Indication hebdomadaire des cas\")+ \n  theme_minimal()+\n  \n  # ajoute un rectangle rouge semi-transparent aux données provisoires\n  annotate(\n    \"rect\",\n    xmin = as.Date(max(central_data$date_onset, na.rm = T) - 21), # la note doit étre enveloppée dans as.Date()\n    xmax = as.Date(Inf), # la note doit étre enveloppée dans as.Date()\n    ymin = 0,\n    ymax = Inf,\n    alpha = 0.2, # alpha facile et intuitif à ajuster en utilisant annotate()\n    fill = \"red\")+\n  \n  # ajoute une ligne verticale noire au-dessus des autres couches\n  annotate(\n    \"segment\",\n    x = max(central_data$date_onset, na.rm = T) - 21, # 21 jours avant les derniéres données\n    xend = max(central_data$date_onset, na.rm = T) - 21, \n    y = 0, # la ligne commence à y = 0\n    yend = Inf, # ligne jusqu'au sommet du graphique\n    size = 2, # taille de la ligne\n    color = \"black\",\n    lty = \"solid\")+ # type de ligne, par exemple \"solid\", \"dashed\".\n\n  # ajouter du texte dans le rectangle\n  annotate(\n    \"text\",\n    x = max(central_data$date_onset, na.rm = T) - 15,\n    y = 15,\n    label = \"Sujet à des délais de déclaration\",\n    angle = 90)\ngeom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,\n           size = 2,\n           color = \"black\")"},{"path":"epicurves.html","id":"couleur-des-barres","chapter":"1 Courbes épidémiques","heading":"Couleur des barres","text":"Une autre approche pourrait consister à ajuster la couleur ou l’affichage des barres de données provisoires elles-mêmes. Vous pouvez créer une nouvelle colonne dans l’étape de préparation des données et l’utiliser pour regrouper les données, de sorte que les ” aes(fill = )`” des données provisoires puissent avoir une couleur ou un alpha différent des autres barres.","code":"\n# ajouter une colonne\n############\nplot_data <- central_data %>% \n  mutate(tentative = case_when(\n    date_onset >= max(date_onset, na.rm=T) - 7 ~ \"Tentative\", # tenative si dans les 7 derniers jours\n    TRUE ~ \"Reliable\")) # tout le reste est fiable\n\n# tracé\n######\nggplot(plot_data, aes(x = date_onset, fill = tentative)) + \n  \n  # histogramme\n  geom_histogram(\n    breaks = weekly_breaks_central, # vecteur de données prédéfini, voir en haut de la page ggplot\n    closed = \"left\",\n    color = \"black\") +\n\n  # échelles\n  scale_y_continuous(expand = c(0,0))+\n  scale_fill_manual(values = c(\"lightblue\", \"grey\"))+\n  scale_x_date(\n    expand = c(0,0), # Supprimez l'espace excédentaire de l'axe des x sous et aprés les barres de cas\n    date_breaks = \"3 weeks\", # Lundi toutes les 3 semaines\n    date_minor_breaks = \"week\", # lundi semaines \n    label = scales::label_date_short())+ # format des étiquettes automatique\n  \n  # étiquettes et theme\n  labs(title = \"Afficher les jours de déclaration provisoire\",\n    subtitle = \"\")+ \n  theme_minimal()+\n  theme(legend.title = element_blank()) # supprimer le titre de la légende"},{"path":"epicurves.html","id":"étiquettes-de-date-à-plusieurs-niveaux","chapter":"1 Courbes épidémiques","heading":"1.4 Étiquettes de date à plusieurs niveaux","text":"Si vous voulez des étiquettes de date à plusieurs niveaux (par exemple, le mois et l’année) sans dupliquer les niveaux d’étiquette inférieurs, envisagez l’une des approches ci-dessous :\nRappelez-vous - vous pouvez utiliser des outils tels que \\n avec les arguments date_labels ou labels pour placer des parties de chaque étiquette sur une nouvelle ligne en dessous. Toutefois, les codes ci-dessous vous aident à placer les années ou les mois (par exemple) sur une ligne inférieure et seulement une fois.La méthode la plus simple est l’argument labels = de scale_x_date() à la fonction label_date_short() du package scales (note : n’oubliez pas d’inclure des parenthèses vides (), comme indiqué ci-dessous). Cette fonction construira automatiquement des étiquettes de date efficaces (pour en savoir plus, cliquez ici). Un autre avantage de cette fonction est que les étiquettes s’adaptent automatiquement à l’évolution de vos données dans le temps : de jours, en semaines, en mois et en années.Une deuxième option consiste à utiliser le facettage. Ci-dessous :Le nombre de cas est agrégé en semaines pour des raisons esthétiques. Voir la page Epicurves (onglet données agrégées) pour plus de détails.Une ligne geom_area() est utilisée au lieu d’un histogramme, car l’approche par facettes ci-dessous ne fonctionne pas bien avec les histogrammes.Aggréger en comptages hebdomadairesFaire des graphiquesLes techniques ci-dessus ont été adaptées de et post sur stackoverflow.com.","code":"\nggplot(central_data) + \n  \n  # histogram\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    breaks = weekly_breaks_central,   \n    closed = \"left\",                  \n    color = \"darkblue\",\n    fill = \"lightblue\") +\n\n  # y-axis \n  scale_y_continuous(expand = c(0,0))+\n  \n  # x-axis\n  scale_x_date(\n    expand = c(0,0),                      \n    date_breaks = \"1 month\", \n    labels = scales::label_date_short())+ # étiquettes de date efficaces\n  \n  # extra\n  labs(\n    title = \"Using label_date_short()\\nTo make automatic and efficient date labels\",\n    x = \"Week of symptom onset\",\n    y = \"Weekly case indicence\")+ \n  theme_minimal()\n# créez un ensemble de données sur le nombre de cas par semaine.\n#######################################\ncentral_weekly <- linelist %>%\n  filter(hospital == \"Central Hospital\") %>% # Filtrer linelist\n  mutate(week = lubridate::floor_date(date_onset, unit = \"weeks\")) %>% # count(week) %>% # count(week)  \n  count(week) %>% # résume le nombre de cas hebdomadaires\n  drop_na(week) %>% # Suppression des cas dont la date d'apparition est manquante\n  complete( # remplir toutes les semaines où aucun cas n'a été signalé\n    week = seq.Date(\n      from = min(week),   \n      to = max(week),\n      by = \"week\"),\n    fill = list(n = 0))                        # convertir les nouvelles valeurs NA en comptage 0\n# tracer avec une bordure de boîte sur l'année\n#################################\nggplot(central_weekly,\n       aes(x = week, y = n)) + # établir x et y pour tout le graphique\n  geom_line(stat = \"identity\", # créer une ligne, la hauteur de la ligne est le nombre de comptage\n            color = \"#69b3a2\") + # couleur de la ligne\n  geom_point(size=1, color=\"#69b3a2\") + # faire des points aux points de données hebdomadaires\n  geom_area(fill = \"#69b3a2\", # zone de remplissage sous la ligne\n            alpha = 0.4)+ # transparence du remplissage\n  scale_x_date(date_labels=\"%b\", # format de l'étiquette de la date pour montrer le mois \n               date_breaks=\"month\", # étiquettes de date au 1er de chaque mois\n               expand=c(0,0)) + # supprimer l'espace excédentaire\n  scale_y_continuous(\n    expand = c(0,0))+ # suppression de l'espace excédentaire sous l'axe des x\n  facet_grid(~lubridate::year(week), # facette sur l'année (de la colonne de la classe Date)\n             space=\"free_x\",                \n             scales=\"free_x\", # les axes x s'adaptent à la plage de données (pas \"fixe\")\n             switch=\"x\") + # étiquettes des facettes (année) en bas de page\n  theme_bw() +\n  theme(strip.placement = \"outside\", # placement des étiquettes de facettes\n          strip.background = element_blank(), # pas de fond d'étiquette de facette\n          panel.grid.minor.x = element_blank(),          \n          panel.border = element_rect(color=\"grey40\"), # bordure grise du PANEL de la facette\n          panel.spacing=unit(0, \"cm\"))+ # Pas d'espace entre les panneaux à facettes\n  labs(title = \"Étiquettes annuelles imbriquées - points, ombrées, bordure d'étiquette\")"},{"path":"epicurves.html","id":"double-axe","chapter":"1 Courbes épidémiques","heading":"1.5 Double axe","text":"Bien qu’il y ait des discussions acharnées sur la validité des doubles axes au sein de la communauté de visualisation des données, de nombreux superviseurs d’épi veulent toujours voir une épicurve ou un graphique similaire avec un pourcentage superposé à un deuxiéme axe. Ce sujet est abordé plus en détail dans la page ggplot tips, mais un exemple utilisant la méthode cowplot est présenté ci-dessous :Deux graphiques distincts sont créés, puis combinés avec le paquet cowplot.Les graphiques doivent avoir exactement le même axe des x (limites définies), sinon les données et les étiquettes ne seront pas alignées.Chacun utilise theme_cowplot() et l’un d’entre eux l’axe des y déplacé sur le côte droit du graphiqueUtilisez maintenant cowplot pour superposer les deux graphiques. Une attention particuliére été portée à l’alignement de l’axe des x, au côte de l’axe des y et à l’utilisation de theme_cowplot().","code":"\n#Chargez le paquet\npacman::p_load(cowplot)\n\n# Faire le premier tracé de l'histogramme épicurve\n#######################################\nplot_cases <- linelist %>% \n  \n  # Tracer les cas par semaine\n  ggplot()+\n  \n  # créer un histogramme  \n  geom_histogram(\n    \n    mapping = aes(x = date_onset),\n    \n    # bin breaks chaque semaine en commençant le lundi avant le premier cas, jusqu'au lundi aprés le dernier cas\n    closed = \"left\",\n    breaks = weekly_breaks_all)+ # vecteur prédéfini de dates hebdomadaires (voir en haut de la section ggplot)\n        \n  # spécifier le début et la fin de l'axe des dates pour l'aligner avec les autres graphiques\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+ # min/max des pauses hebdomadaires prédéfinies de l'histogramme\n  \n  # étiquettes\n  labs(\n      y = \"Cas quotidiens\",\n      x = \"Date d'apparition des symptômes\"\n    )+\n  theme_cowplot()\n\n\n# faire un second tracé du pourcentage de décés par semaine\n###########################################\nplot_deaths <- linelist %>% # commence avec linelist\n  group_by(week = floor_date(date_onset, \"week\")) %>% # créer une colonne semaine\n  \n  # résumer pour obtenir le pourcentage hebdomadaire de cas décédés\n  summarise(n_cases = n(),\n            died = sum(outcome == \"Death\", na.rm=T),\n            pct_died = 100*died/n_cases) %>% \n  \n  # commencer le tracé\n  ggplot()+\n  \n  # ligne du pourcentage hebdomadaire de décés\n  geom_line( # créer une ligne de pourcentage de décés\n    mapping = aes(x = week, y = pct_died), # spécifie la hauteur des y comme colonne pct_died\n    stat = \"identity\", # fixer la hauteur de la ligne à la valeur de la colonne pct_death, et non au nombre de lignes (par défaut)\n    size = 2,\n    color = \"black\")+\n  \n  # mêmes limites de l'axe des dates que l'autre graphique - alignement parfait\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+ # min/max des pauses hebdomadaires prédéfinies de l'histogramme\n  \n  \n  # ajustements de l'axe des y\n  scale_y_continuous( # ajuster l'axe des y\n    breaks = seq(0,100, 10), # définit les intervalles de rupture de l'axe des pourcentages\n    limits = c(0, 100), # définit l'étendue de l'axe des pourcentages\n    position = \"right\")+ # déplace l'axe des pourcentages vers la droite\n  \n  # étiquette pour l'axe des Y, pas d'étiquette pour l'axe des X\n  labs(x = \"\",\n       y = \"Pourcentage décédé\") +  # étiquette de l'axe des pourcentages\n  \n  theme_cowplot() # ajoutez ceci pour que les deux graphiques fusionnent bien ensemble\naligned_plots <- cowplot::align_plots(plot_cases, plot_deaths, align=\"hv\", axis=\"tblr\")\n\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])"},{"path":"epicurves.html","id":"incidence-cumulée","chapter":"1 Courbes épidémiques","heading":"1.6 Incidence cumulée","text":"Cette page traitera de la façon de calculer l’incidence cumulée et de la tracer avec ggplot().Si vous commencez avec une liste de cas, créez une nouvelle colonne contenant le nombre cumulé de cas par jour dans une épidémie en utilisant cumsum() de base R :Les 10 premiéres lignes sont affichôes ci-dessous :Cette colonne cumulative peut ensuite étre tracée en fonction de la date_onset, en utilisant `geom_line()`` :peut aussi le superposer à l’épicurve, avec un double axe en utilisant la méthode cowplot décrite ci-dessus et dans la page ggplot tips :Utilisez maintenant cowplot pour superposer les deux graphiques. Une attention particuliére été portée à l’alignement de l’axe des x, au côte de l’axe des y et à l’utilisation de theme_cowplot().","code":"\ncumulative_case_counts <- linelist %>% \n  count(date_onset) %>% # nombre de lignes par jour (retourné dans la colonne \"n\")   \n  mutate(                         \n    cumulative_cases = cumsum(n) # nouvelle colonne du nombre cumulé de lignes à chaque date\n    )\nplot_cumulative <- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")\n\nplot_cumulative\n#charger le paquet\n\npacman::p_load(cowplot)\n\n\n# Faire le premier tracé de l'histogramme épicurve\nplot_cases <- ggplot()+\n  geom_histogram(          \n    data = linelist,\n    aes(x = date_onset),\n    binwidth = 1)+\n  labs(\n    y = \"Cas quotidiens\",\n    x = \"Date d'apparition des symptômes\"\n  ) +\n  theme_cowplot()\n\n# créer un second tracé de la ligne des cas cumulés\nplot_cumulative <- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")+\n  scale_y_continuous(\n    position = \"right\")+\n  labs(x = \"\",\n       y = \"Cas cumulés\")+\n  theme_cowplot()+\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.title.x = element_blank(),\n    axis.ticks = element_blank())\naligned_plots <- cowplot::align_plots(plot_cases, plot_cumulative, align=\"hv\", axis=\"tblr\")\n\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])"},{"path":"epicurves.html","id":"ressources","chapter":"1 Courbes épidémiques","heading":"1.7 Ressources","text":"","code":""}]
