[{"path":"index.html","id":"section","chapter":"","heading":"","text":"","code":""},{"path":"index.html","id":"r-pour-lépidémiologie-appliquée-et-la-santé-publique","chapter":"","heading":"R pour l’épidémiologie appliquée et la santé publique","text":"Utilisation : Ce manuel été utilisé plus d’un million de fois par 400 000 personnes dans le monde entier.Objectif: Servir de manuel de référence rapide du code R (en ligne et Télécharger le manuel et les données) avec des exemples centrés sur la tâche qui traitent des problèmes épidémiologiques courants.Essayez nos tutoriels interactifs gratuits ou notre cours d’introduction synchrone et virtuel utilisé par les CDC américains, l’OMS et plus de 130 autres agences de santé et programmes de formation à l’épidémiologie sur le terrain dans le monde entier.Langues: Anglais (English), Espagnol (Español), Vietnamien (Tiếng Việt), Japonais (日本), Turc (Türkçe), Francais, Portugais (Português)Rédigé par des épidémiologistes, pour des épidémiologistes \nApplied Epi est une organisation à non lucratif et un mouvement d’épis de première ligne du monde entier. Nous écrivons pendant notre temps libre pour offrir cette ressource à la communauté. Vos encouragements et vos commentaires sont les bienvenus :Visitez notre site web et rejoignez notre liste de contacts.contact@appliedepi.org, tweeter @appliedepi, ou LinkedInSoumettre des problèmes à notre dépôt GithubNous proposons des formations R en direct dispensées par des formateurs ayant des décennies d’expérience en épidémiologie appliquée - envoyez-nous un courriel pour en discuter.","code":""},{"path":"index.html","id":"comment-utiliser-ce-manuel","chapter":"","heading":"Comment utiliser ce manuel","text":"Parcourez les pages de la table des matières ou utilisez la boîte de recherche.Cliquez sur les icônes “copier” pour copier le code.Vous pouvez suivre avec les données d’exemple de le chapitre.Version hors ligneVoir les instructions de la page Télécharger le manuel et les données.","code":""},{"path":"index.html","id":"remmerciements","chapter":"","heading":"Remmerciements","text":"Cet ouvrage est le fruit du travail d’une équipe internationale d’épidémiologistes, qui se sont appuyés sur leur expérience auprès d’organisations telles que les agences sanitaires locales, régionales, provinciales et nationales de divers pays, l’Organisation mondiale de la santé (OMS), Médecins Sans Frontières (MSF), les systèmes hospitaliers et les institutions universitaires.Ce guide n’est pas un produit approuvé par une organisation spécifique. Bien que nous nous soyons efforcés à être précis, nous ne pouvons fournir aucune garantie quant au contenu de ce livre.","code":""},{"path":"index.html","id":"auteurs-et-contributeurs","chapter":"","heading":"Auteurs et contributeurs","text":"Editeur: Neale BatraCommité éditorial Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay CampbellAuteurs et autrices: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen Lin, Olivia BoydRelecture: Pat Keating, Annick Lenglet, Margot Charette, Danielly Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao MuiangaIllustrations: Calder FongTraduction: Aminata Ndiaye, Anais Legrand, Marie-Amelie Degail-Chabrat, Yves Amevoin, Laura Downham, Lise Grout, Margot Charette, Mathilde Mousset, Noe Guincko, Mor Ndiaye, Elysée Junior, Nerisson Joseph, Bryan Tegomoh, Marcel Woung, Olivia Boyd, Amy Mikhail, Lucie Fournier, Paul-Evans Ehouman, Kelly McCain","code":""},{"path":"index.html","id":"financements","chapter":"","heading":"Financements","text":"Le manuel reçu un financement de soutien via une subvention d’urgence COVID-19 pour le renforcement des capacités de la part de TEPHINET, le réseau mondial des programmes de formation en épidémiologie de terrain (FETP).Le réseau des anciens d’EPIET (EAN) fourni un soutien administratif (Annika Wendland en particulier). EPIET est le programme européen de formation en épidémiologie d’intervention.Nous remercions tout particulièrement le Centre Opérationnel d’Amsterdam de Médecins Sans Frontières (MSF OCA) pour son soutien lors de l’élaboration de ce manuel.Cette publication été soutenue par l’accord de coopération numéro NU2GGH001873, financé par les Centers Disease Control Prevention par le biais de TEPHINET, un programme de “Task Force Global Health”. Son contenu relève de la seule responsabilité des auteurs et ne reflète pas les opinions officielles des Centers Disease Control Prevention, du Department Health Human Services, de Task Force Global Health, Inc. ou de TEPHINET.","code":""},{"path":"index.html","id":"inspirations","chapter":"","heading":"Inspirations","text":"Nous nous sommes inspiré de multiples tutoriels, livres et vignettes développés par la communauté pour développer ce manuel. Ces ressources, sont crédités dans les chapitres respectifs, mais nous souhaitons citer quelques sources d’inspiration générales que nous utilisons de manière récurrente :“R4Epis” project (une collaboration entre MSF et RECON)R Epidemics Consortium (RECON)R Data Science book (R4DS)bookdown: Authoring Books Technical Documents R MarkdownNetlify qui héberge ce site","code":""},{"path":"index.html","id":"conditions-dutilisation-et-contribution","chapter":"","heading":"Conditions d’utilisation et contribution","text":"","code":""},{"path":"index.html","id":"license","chapter":"","heading":"License","text":"Ce document est mis à disposition selon les termes de lalicence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International (CC -NC-SA 4.0) .N’hésitez pas à utiliser les contenus de ce manuel dans vos cours et formations en épidémiologie, ou à le conseiller à vos étudiants. Si vous avez des questions sur l’utilisation que vous souhaitez en faire, envoyez un courriel à contact@appliedepi.org.","code":""},{"path":"index.html","id":"citation","chapter":"","heading":"Citation","text":"Batra, Neale, et al. Epidemiologist R Handbook. 2021. ","code":""},{"path":"index.html","id":"contribuer","chapter":"","heading":"Contribuer","text":"Si vous souhaitez contribuer à cet ouvrage, veuillez d’abord nous contacter via les tickets (issues) Github ou par courriel. Nous sommes en train de développer un calendrier de mise à jour et un guide du contributeur.Veuillez noter que le projet epiRhandbook est publié avec un code de conduite du contributeur. En contribuant à ce projet, vous acceptez de vous conformer à ses conditions.","code":""},{"path":"epidemic_models.html","id":"epidemic_models","chapter":"1 Modélisation des épidémies","heading":"1 Modélisation des épidémies","text":"","code":""},{"path":"epidemic_models.html","id":"overview","chapter":"1 Modélisation des épidémies","heading":"1.1 Overview","text":"Il existe un nombre croissant d’outils pour la modélisation des épidémies qui nous permettent de mener des analyses assez complexes avec un effort minimal.Cette section fournira une\naperçu sur la façon d’utiliser ces outils pour :estimer le nombre de reproduction effectif Rt et les statistiques connexes.\ntelles que le temps de doublementproduire des projections à court terme de l’incidence future.Il ne s’agit pas d’un aperçu des méthodologies et des méthodes statistiques qui sous-tendent ces outils. Veuillez donc vous référer à l’onglet Ressources pour des liens vers des\ndocuments traitant de ce sujet. Assurez-vous d’avoir une bonne compréhension des\nles méthodes avant d’utiliser ces outils ; cela vous permettra d’interpréter correctement\nleurs résultats.Voici un exemple de l’un des résultats que nous produirons dans cette section.","code":""},{"path":"epidemic_models.html","id":"préparation","chapter":"1 Modélisation des épidémies","heading":"1.2 Préparation","text":"Nous allons utiliser deux méthodes et packages différents pour l’estimation Rt,\nà savoir EpiNow et EpiEstim, ainsi que le package projections pour la prévision de l’incidence des cas.Ce fragment de code montre le chargement des paquets nécessaires aux analyses. Dans ce manuel, nous mettons l’accent sur p_load() de pacman, qui installe le paquet si nécessaire et le charge pour l’utiliser. Vous pouvez également charger les paquets installés avec library() de base R. Voir la page sur R basics pour plus d’informations sur les paquets R.Nous utiliserons la linelist de cas nettoyée pour toutes les analyses de cette section. Si vous voulez suivre, cliquez pour télécharger la linelist “propre” (en tant que fichier .rds). Consultez la page Télécharger le manuel et les données pour télécharger tous les exemples de données utilisés dans ce manuel.","code":"\npacman::p_load(\n   rio, # Importation de fichiers\n   here, # Localisation de fichiers\n   tidyverse, # Gestion des données + graphiques ggplot2\n   epicontacts, # Analyse des réseaux de transmission\n   EpiNow2, # Estimation de Rt\n   EpiEstim, # Estimation Rt\n   projections, # Projections d'incidence\n   incidence2, # Traitement des données d'incidence\n   epitrix, # Fonctions epi utiles\n   distcrete # Distributions discrètes des délais\n)\n# Importez la liste de cas nettoyée\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"epidemic_models.html","id":"estimation-de-rt","chapter":"1 Modélisation des épidémies","heading":"1.3 Estimation de Rt","text":"","code":""},{"path":"epidemic_models.html","id":"epinow2-vs.-epiestim","chapter":"1 Modélisation des épidémies","heading":"EpiNow2 vs. EpiEstim","text":"Le taux de reproduction R est une mesure de la transmissibilité d’une maladie, et est défini comme le nombre attendu de cas secondaires par cas infecté. Dans une population totalement sensible, cette valeur représente le nombre de reproduction de base, R0. Cependant, comme le nombre d’individus sensibles dans une population évolue au cours d’une épidémie ou d’une pandémie, et que diverses mesures de réponse sont mises en œuvre, la mesure la plus couramment utilisée de la transmissibilité est le taux de reproduction effectif, Rt ; il est défini défini comme le nombre attendu de cas secondaires par cas infecté à un moment, t.Le paquet EpiNow2 fournit le cadre le plus sophistiqué pour l’estimation de Rt. Il présente deux avantages essentiels par rapport à l’autre paquet couramment utilisé, EpiEstim :Il tient compte des délais de déclaration et peut donc estimer Rt même lorsque les données récentes sont incomplètes.Il estime Rt sur les dates d’infection plutôt que sur les dates de début de déclaration, ce qui signifie que l’effet d’une intervention sera immédiatement reflété dans un changement de Rt, plutôt qu’avec un delai.Cependant, elle présente également deux inconvénients majeurs :Elle nécessite la connaissance de la distribution des temps de génération (c’est-à-dire la distribution des délais entre l’infection d’un cas primaire et d’un cas secondaire), la distribution de la période d’incubation (c’est-à-dire la distribution des délais entre l’infection et l’apparition des symptômes) et toute autre distribution de délai pertinente pour vos données (par exemple, si vous avez des dates de déclaration, vous avez besoin de la distribution des délais entre l’apparition des symptômes et la déclaration, ou la période d’incubation). Bien que cela permette une estimation plus précise de Rt, EpiEstim ne requiert que la distribution de l’intervalle sériel (c’est-à-dire la distribution des délais entre l’apparition des symptômes d’un cas primaire et d’un cas secondaire), qui peut être la seule distribution disponible pour vous.EpiNow2 est significativement plus lent que EpiEstim, de manière anecdotique par un facteur de 100 à 1000 ! Par exemple, l’estimation de Rt pour l’échantillon de foyers considéré dans cette section prend environ quatre heures (ceci été exécuté pour un grand d’itérations pour garantir une grande précision et pourrait probablement être réduite si nécessaire) mais il n’en reste pas moins que l’algorithme est lent en général. Cela peut être irréalisable si vous mettez régulièrement à jour votre base de données pour Rt.Le paquet que vous choisirez d’utiliser dépendra donc des données, du temps et des ressources informatiques dont vous disposez.","code":""},{"path":"epidemic_models.html","id":"epinow2","chapter":"1 Modélisation des épidémies","heading":"EpiNow2","text":"","code":""},{"path":"epidemic_models.html","id":"estimation-des-distributions-de-retard","chapter":"1 Modélisation des épidémies","heading":"1.3.0.1 Estimation des distributions de retard","text":"Les distributions de retard requises pour exécuter EpiNow2 dépendent des données dont vous disposez. Essentiellement, vous devez être en mesure de décrire le délai entre la date d’infection à la date de l’événement que vous voulez utiliser pour estimer Rt. Si\nvous utilisez les dates d’apparition, il s’agit simplement de la distribution de la période d’incubation. Si vous utilisez les dates de déclaration, vous avez besoin du\ndélai entre l’infection et la déclaration. Comme il est peu probable que cette distribution soit connue directement, EpiNow2 vous permet d’enchaîner plusieurs distributions de délai ; dans ce cas, le délai entre l’infection et la déclaration est le même.Comme nous disposons des dates d’apparition des symptômes pour tous nos cas dans la liste d’exemples, nous n’aurons besoin que de la distribution de la période d’incubation pour déterminer le délai d’apparition des symptômes.Nous pouvons soit estimer cette distribution\nà partir des données ou utiliser les valeurs de la littérature.Une estimation de la période d’incubation d’Ebola dans la littérature (tirée de cet article) avec une moyenne de 9,1, un écart-type de 7,3 et une valeur maximale de 30, serait spécifiée comme suit :Notez que EpiNow2 exige que ces distributions de délais soient fournies sur une échelle log d’où l’appel log autour de chaque valeur (sauf le paramètre max qui doit être fourni sur une échelle naturelle). Les paramètres mean_sd et sd_sd définissent l’écart type des estimations de la moyenne. Comme ceux-ci ne sont pas connus dans ce cas, nous choisissons la valeur assez arbitraire de 0.1.Dans cette analyse, nous estimons plutôt la distribution de la période d’incubation à partir de la linelist elle-même en utilisant la fonction bootstrapped_dist_fit, ce qui va\nune distribution lognormale aux délais observés entre l’infection et l’apparition de la maladie.L’autre distribution dont nous avons besoin est le temps de génération. Comme nous avons des données sur les temps d’infection et les liens de transmission, nous pouvons estimer cette\ndistribution à partir de la liste de liens en calculant le délai entre les temps d’infection\ndes paires infecteur-infecte. Pour ce faire, nous utilisons la fonction pratique get_pairwise du paquet epicontacts, qui nous permet de calculer les différences par paire des propriétés de la linelist entre les paires de transmission. Nous créons d’abord un objet epicontacts (voir la page Chaînes de transmission pour plus de détails) :Nous ajustons ensuite la différence de temps d’infection entre les paires de transmission,\ncalculée en utilisant get_pairwise, à une distribution gamma :","code":"\nincubation_period_lit <- list(\n  mean = log(9.1),\n  mean_sd = log(0.1),\n  sd = log(7.3),\n  sd_sd = log(0.1),\n  max = 30\n)\n## Estimation de la période d'incubation\nincubation_period <- bootstrapped_dist_fit(\n  linelist$date_onset - linelist$date_infection,\n  dist = \"lognormal\",\n  max_value = 100,\n  bootstraps = 1\n)\n## générer des contacts\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## générer un objet epicontacts\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n## estimation du temps de génération gamma\ngeneration_time <- bootstrapped_dist_fit(\n  get_pairwise(epic, \"date_infection\"),\n  dist = \"gamma\",\n  max_value = 20,\n  bootstraps = 1\n)"},{"path":"epidemic_models.html","id":"exécution-de-epinow2","chapter":"1 Modélisation des épidémies","heading":"Exécution de EpiNow2","text":"Maintenant, il ne nous reste plus qu’à calculer l’incidence journalière à partir de la liste linéaire, ce que nous pouvons faire facilement avec les fonctions dplyr group_by() et n(). Notez que EpiNow2 exige que les noms des colonnes soient date et confirm.Nous pouvons ensuite estimer Rt en utilisant la fonction epinow. Quelques remarques sur les entrées :Nous pouvons fournir n’importe quel nombre de distributions de délais “enchaînés” à l’argument delays.\nNous les insérons simplement à côté de l’objet incubation_period dans la fonction delay_opts.return_output permet de s’assurer que la sortie est retournée dans R et pas seulement\nun fichier.verbose spécifie que nous voulons une lecture de la progression.horizon indique pour combien de jours nous voulons projeter l’incidence future.Nous passons des options supplémentaires à l’argument stan pour spécifier combien de temps\nnous voulons exécuter l’inférence pour. L’augmentation de samples et de chains vous donnera une estimation plus précise qui caractérisera mieux l’incertitude.Cependant, l’exécution sera plus longue.","code":"\n## Obtenir l'incidence à partir des dates d'apparition\ncases <- linelist %>%\n  group_by(date = date_onset) %>%\n  summarise(confirm = n())\n## exécuter epinow\nepinow_res <- epinow(\n  reported_cases = cases,\n  generation_time = generation_time,\n  delays = delay_opts(incubation_period),\n  return_output = TRUE,\n  verbose = TRUE,\n  horizon = 21,\n  stan = stan_opts(samples = 750, chains = 4)\n)"},{"path":"epidemic_models.html","id":"analyser-les-sorties","chapter":"1 Modélisation des épidémies","heading":"Analyser les sorties","text":"Une fois l’exécution du code terminée, nous pouvons tracer un résumé très facilement comme suit. Faites défiler l’image pour voir l’étendue complète.Nous pouvons également examiner diverses statistiques sommaires :Pour des analyses plus approfondies et des tracés personnalisés, vous pouvez accéder aux estimations quotidiennes résumées via $estimates$summarised. Nous allons convertir le tableau par défaut data.table en un tibble pour faciliter l’utilisation avec dplyr.titre d’exemple, faisons un graphique du temps de doublement et de Rt. Nous n’examinerons que les premiers mois de l’épidémie, lorsque Rt est largement\nsupérieur à un, pour éviter de tracer des temps de doublement extrêmement élevés.Nous utilisons la formule log(2)/taux de croissance pour calculer le temps de doublement à partir du taux de croissance estimé.","code":"\n## Tracer la figure récapitulative\nplot(epinow_res)\n## tableau récapitulatif\nepinow_res$summary##                                  measure                  estimate  numeric_estimate\n## 1: New confirmed cases by infection date                4 (2 -- 6) <data.table[1x9]>\n## 2:        Expected change in daily cases                    Unsure              0.56\n## 3:            Effective reproduction no.        0.88 (0.73 -- 1.1) <data.table[1x9]>\n## 4:                        Rate of growth -0.012 (-0.028 -- 0.0052) <data.table[1x9]>\n## 5:          Doubling/halving time (days)          -60 (130 -- -25) <data.table[1x9]>\n## extraire le résumé et le convertir en tibble\nestimates <- as_tibble(epinow_res$estimates$summarised)\nestimates\n## faire des df larges pour le tracé de la médiane\ndf_wide <- estimates %>%\n  filter(\n    variable %in% c(\"growth_rate\", \"R\"),\n    date < as.Date(\"2014-09-01\")\n  ) %>%\n  ## convertir les taux de croissance en temps de doublement\n  mutate(\n    across(\n      c(median, lower_90:upper_90),\n      ~ case_when(\n        variable == \"growth_rate\" ~ log(2)/.x,\n        TRUE ~ .x\n      )\n    ),\n    ## renommer la variable pour refléter la transformation\n    variable = replace(variable, variable == \"growth_rate\", \"doubling_time\")\n  )\n\n## créer des df longs pour le tracé des quantiles\ndf_long <- df_wide %>%\n  ## ici, nous faisons correspondre les quantiles (par exemple, lower_90 à upper_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## créer un graphique\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  ## utiliser label_parsed pour permettre l'utilisation d'une étiquette en indice\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(R = \"R[t]\", doubling_time = \"Doubling~time\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## définir manuellement la transparence des quantiles\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )"},{"path":"epidemic_models.html","id":"epiestim","chapter":"1 Modélisation des épidémies","heading":"EpiEstim","text":"Pour exécuter EpiEstim, nous devons fournir des données sur l’incidence journalière et spécifier l’intervalle sériel (c’est-à-dire la distribution des délais entre l’apparition des symptômes des cas primaires et secondaires).Les données d’incidence peuvent être fournies à EpiEstim sous la forme d’un vecteur, d’un cadre de données ou d’un objet incidence provenant du paquetage original incidence. Vous pouvez même faire la distinction entre les importations et les infections acquises localement ; voir la documentation de ?estimate_R pour plus de détails.Nous allons créer l’entrée en utilisant incidence2. Voir la page sur Epidemic curves pour plus d’exemples avec le paquet incidence2. Comme il y eu des mises à jour du paquet incidence2 qui ne correspondent pas complètement à l’entrée attendue de estimateR(), quelques étapes supplémentaires mineures sont nécessaires. L’objet incidence consiste en un tibble avec des dates et leurs nombres de cas respectifs. Nous utilisons complete() de tidyr pour nous assurer que toutes les dates sont incluses (même celles sans cas), puis nous rename() les colonnes pour les aligner avec ce qui est attendu par estimate_R() dans une étape ultérieure.Le paquetage fournit plusieurs options pour spécifier l’intervalle sériel, dont les détails sont fournis dans la documentation de ?estimate_R.","code":"\n## Obtenir l'incidence à partir de la date d'apparition\ncases <- incidence2::incidence(linelist, date_index = \"date_onset\") %>% # obtient le nombre de cas par jour\n  tidyr::complete(date_index = seq.Date( # s'assurer que toutes les dates sont représentées\n    from = min(date_index, na.rm = T),\n    to = max(date_index, na.rm=T),\n    by = \"day\"),\n    fill = list(count = 0)) %>% # convertit les comptes NA en 0\n  rename(I = count, # renomme aux noms attendus par estimateR\n         dates = date_index)"},{"path":"epidemic_models.html","id":"utiliser-des-estimations-dintervalles-sériels-issues-de-la-littérature","chapter":"1 Modélisation des épidémies","heading":"Utiliser des estimations d’intervalles sériels issues de la littérature","text":"En utilisant l’option method = \"parametric_si\", nous pouvons spécifier manuellement la moyenne et l’écart type de l’intervalle sériel dans la littérature ou dans un objet config créé à l’aide de la fonction make_config. Nous utilisons une moyenne et un écart-type de 12.0 et 5.2, respectivement, définis dans cet article :Nous pouvons ensuite estimer Rt avec la fonction estimate_R :et tracer un résumé des résultats :","code":"\n## créer config\nconfig_lit <- make_config(\n  mean_si = 12.0,\n  std_si = 5.2\n)\ncases <- cases %>% \n     filter(!is.na(date))\n\n\n#créer un cadre de données pour la fonction estimate_R()\ncases_incidence <- data.frame(dates = seq.Date(from = min(cases$dates),\n                               to = max(cases$dates), \n                               by = 1))\n\ncases_incidence <- left_join(cases_incidence, cases) %>% \n     select(dates, I) %>% \n     mutate(I = ifelse(is.na(I), 0, I))## Joining with `by = join_by(dates)`\nepiestim_res_lit <- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_lit\n)## Default config will estimate R on weekly sliding windows.\n##     To change this change the t_start and t_end arguments.\nplot(epiestim_res_lit)"},{"path":"epidemic_models.html","id":"utilisation-destimations-dintervalles-en-série-à-partir-des-données","chapter":"1 Modélisation des épidémies","heading":"Utilisation d’estimations d’intervalles en série à partir des données","text":"Comme nous avons des données sur les dates d’apparition des symptômes et les liens de transmission, nous pouvons également estimer l’intervalle sériel à partir de la liste de liens en calculant le délai entre les dates d’apparition des symptômes des paires infecteur-infecté.\nComme nous l’avons fait dans la section EpiNow2 nous allons utiliser la fonction get_pairwise du paquet epicontacts qui nous permet de calculer les différences par paires des propriétés de la liste de liens entre les paires de transmission. Nous créons d’abord un objet epicontacts (voir la page Chaînes de transmission pour plus de détails) :Nous ajustons ensuite la différence de dates d’apparition entre les paires de transmissions, calculée en utilisant get_pairwise, à une distribution gamma. Nous utilisons l’outil pratique fit_disc_gamma du paquet epitrix pour cette procédure d’ajustement, car nous avons besoin d’une distribution discrète.Nous passons ensuite ces informations à l’objet config, exécutons EpiEstim et traçons les résultats :","code":"\n## générer des contacts\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## générer un objet epicontacts\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n## Estimation de l'intervalle sériel gamma\nserial_interval <- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n## faire le config\nconfig_emp <- make_config(\n  mean_si = serial_interval$mu,\n  std_si = serial_interval$sd\n)\n\n## Exécuter epiestim\nepiestim_res_emp <- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_emp\n)## Default config will estimate R on weekly sliding windows.\n##     To change this change the t_start and t_end arguments.\n## tracer les résultats\nplot(epiestim_res_emp)"},{"path":"epidemic_models.html","id":"spécification-des-fenêtres-temporelles-destimation","chapter":"1 Modélisation des épidémies","heading":"Spécification des fenêtres temporelles d’estimation","text":"Ces options par défaut fournissent une estimation hebdomadaire glissante et peuvent servir d’avertissement si vous estimez Rt trop tôt dans l’épidémie pour une estimation précise.Vous pouvez changer cela en fixant une date de début ultérieure pour l’estimation de Rt, comme indiqué ci-dessous.Malheureusement, EpiEstim n’offre qu’une façon très maladroite de spécifier ces temps d’estimation, en ce sens que vous devez fournir un vecteur d’entiers __ se référant aux dates de début et de fin de chaque fenêtre temporelle.Maintenant, nous réexécutons EpiEstim et nous pouvons voir que les estimations ne commencent qu’à partir de juin :","code":"\n## définir un vecteur de dates commençant le 1er juin\nstart_dates <- seq.Date(\n  as.Date(\"2014-06-01\"),\n  max(cases$dates) - 7,\n  by = 1\n) %>%\n  ## soustraire la date de départ pour la convertir en numérique\n  `-`(min(cases$dates)) %>%\n  ## convertir en entier\n  as.integer()\n\n## ajouter six jours pour une fenêtre glissante d'une semaine\nend_dates <- start_dates + 6\n  \n## faire la configuration\nconfig_partial <- make_config(\n  mean_si = 12.0,\n  std_si = 5.2,\n  t_start = start_dates,\n  t_end = end_dates\n)\n## exécuter epiestim\nepiestim_res_partial <- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_partial\n)\n\n## tracer les résultats\nplot(epiestim_res_partial)"},{"path":"epidemic_models.html","id":"analyser-les-sorties-1","chapter":"1 Modélisation des épidémies","heading":"Analyser les sorties","text":"Les principales sorties sont accessibles via $R. titre d’exemple, nous allons créer un graphe de Rt et une mesure de “potentiel de transmission” donnée par le produit de\nRt et du nombre de cas signalés ce jour-là ; cela représente le\nnombre attendu de cas dans la prochaine génération d’infection.","code":"\n## créer un cadre de données large pour la médiane\ndf_wide <- epiestim_res_lit$R %>%\n  rename_all(clean_labels) %>%\n  rename(\n    lower_95_r = quantile_0_025_r,\n    lower_90_r = quantile_0_05_r,\n    lower_50_r = quantile_0_25_r,\n    upper_50_r = quantile_0_75_r,\n    upper_90_r = quantile_0_95_r,\n    upper_95_r = quantile_0_975_r,\n    ) %>%\n  mutate(\n    ## extraire la date médiane de t_start et t_end\n    dates = epiestim_res_emp$dates[round(map2_dbl(t_start, t_end, median))],\n    var = \"R[t]\"\n  ) %>%\n  ## fusionner les données d'incidence quotidienne\n  left_join(cases, \"dates\") %>%\n  ## calculer le risque pour toutes les estimations r\n  mutate(\n    across(\n      lower_95_r:upper_95_r,\n      ~ .x*I,\n      .names = \"{str_replace(.col, '_r', '_risk')}\"\n    )\n  ) %>%\n  ## séparer les estimations de r et les estimations de risque\n  pivot_longer(\n    contains(\"median\"),\n    names_to = c(\".value\", \"variable\"),\n    names_pattern = \"(.+)_(.+)\"\n  ) %>%\n  ## Assigner des niveaux de facteurs\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## créer un cadre de données long à partir des quantiles\ndf_long <- df_wide %>%\n  select(-variable, -median) %>%\n  ## séparer les estimations de r/risque et les niveaux de quantile\n  pivot_longer(\n    contains(c(\"lower\", \"upper\")),\n    names_to = c(\".value\", \"quantile\", \"variable\"),\n    names_pattern = \"(.+)_(.+)_(.+)\"\n  ) %>%\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## créer un graphique\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = dates, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = dates, y = median),\n    alpha = 0.2\n  ) +\n  ## utiliser label_parsed pour permettre l'utilisation d'une étiquette en indice\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(r = \"R[t]\", risk = \"Transmission~potential\"), label_parsed),\n    strip.position = 'left' \n  ) +\n  ## définir manuellement la transparence des quantiles\n  scale_alpha_manual(\n    values = c(`50` = 0.7, `90` = 0.4, `95` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside' \n  )"},{"path":"epidemic_models.html","id":"projection-de-lincidence","chapter":"1 Modélisation des épidémies","heading":"1.4 Projection de l’incidence","text":"","code":""},{"path":"epidemic_models.html","id":"epinow2-1","chapter":"1 Modélisation des épidémies","heading":"EpiNow2","text":"En plus de l’estimation de Rt, EpiNow2 permet également la prévision de\nRt et les projections du nombre de cas par l’intégration avec le paquet EpiSoon sous le capot. Tout ce que vous avez à faire est de spécifier l’argument horizon dans votre appel de fonction epinow, indiquant le nombre de jours que vous voulez projeter dans le futur ; voir la section EpiNow2 sous la rubrique “Estimation\nRt” pour plus de détails sur la façon de mettre en place EpiNow2. Dans cette\nsection, nous allons simplement tracer les sorties de cette analyse, stockées dans le fichier\nl’objet epinow_res.","code":"\n## définir la date minimale pour le tracé\nmin_date <- as.Date(\"2015-03-01\")\n\n## extraire les estimations résumées\nestimates <- as_tibble(epinow_res$estimates$summarised)\n\n## extraire les données brutes sur l'incidence des cas\nobservations <- as_tibble(epinow_res$estimates$observations) %>%\n  filter(date > min_date)\n\n## extraire les estimations prévisionnelles du nombre de cas\ndf_wide <- estimates %>%\n  filter(\n    variable == \"reported_cases\",\n    type == \"forecast\",\n    date > min_date\n  )\n\n## convertir en un format encore plus long pour le tracé des quantiles\ndf_long <- df_wide %>%\n  ## ici nous faisons correspondre les quantiles (par exemple, lower_90 à upper_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## créer un graphique\nggplot() +\n  geom_histogram(\n    data = observations,\n    aes(x = date, y = confirm),\n    stat = 'identity',\n    binwidth = 1\n  ) +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  geom_vline(xintercept = min(df_long$date), linetype = 2) +\n  ## Définir manuellement la transparence des quantiles\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = \"Daily reported cases\",\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n    theme_minimal(base_size = 14)"},{"path":"epidemic_models.html","id":"projections","chapter":"1 Modélisation des épidémies","heading":"projections","text":"Le paquet projections développé par RECON permet de faire très facilement des prévisions d’incidence à court terme, ne nécessitant que la connaissance du nombre de reproduction effectif de reproduction Rt et de l’intervalle de série. Nous verrons ici comment utiliser des estimations d’intervalle sériel de la littérature et comment utiliser nos propres estimations de la liste de diffusion.","code":""},{"path":"epidemic_models.html","id":"utiliser-les-estimations-dintervalles-sériels-de-la-littérature","chapter":"1 Modélisation des épidémies","heading":"Utiliser les estimations d’intervalles sériels de la littérature","text":"projections nécessite une distribution d’intervalle série discrétisée de la classe distcrete du paquet distcrete. Nous utiliserons une distribution gamma avec une moyenne de 12,0 et un écart-type de 5,2 définie dans cet article. Pour convertir ces valeurs en paramètres de forme et d’échelle requis pour une distribution gamma. nous utiliserons la fonction gamma_mucv2shapescale du paquet epitrix.Voici une vérification rapide pour s’assurer que l’intervalle de série est correct. Nous accédons à la densité de la distribution gamma que nous venons de définir par $d, ce qui revient à appeler dgamma :","code":"\n## obtenir les paramètres de forme et d'échelle à partir du mu moyen et du coefficient de\n## variation (par exemple, le rapport entre l'écart type et la moyenne).\nshapescale <- epitrix::gamma_mucv2shapescale(mu = 12.0, cv = 5.2/12)\n\n## fabriquer un objet distcrete\nserial_interval_lit <- distcrete::distcrete(\n  name = \"gamma\",\n  interval = 1,\n  shape = shapescale$shape,\n  scale = shapescale$scale\n)\n## vérifiez que l'intervalle série est correct\nqplot(\n  x = 0:50, y = serial_interval_lit$d(0:50), geom = \"area\",\n  xlab = \"Serial interval\", ylab = \"Density\"\n)"},{"path":"epidemic_models.html","id":"utilisation-des-estimations-dintervalles-sériels-à-partir-des-données","chapter":"1 Modélisation des épidémies","heading":"Utilisation des estimations d’intervalles sériels à partir des données","text":"Comme nous avons des données sur les dates d’apparition des symptômes et les liens de transmission, nous pouvons également estimer l’intervalle sériel à partir de la liste de liens en calculant le délai entre les dates d’apparition des symptômes des paires infecteur-infecté. Comme nous l’avons fait dans la section EpiNow2, nous allons utiliser la fonction get_pairwise du paquet epicontacts qui nous permet de calculer les différences par paires des propriétés de la liste de liens entre les paires de transmission. Nous créons d’abord un objet epicontacts (voir la page Chaînes de transmission pour plus de détails) :Nous ajustons ensuite la différence de dates d’apparition entre les paires de transmissions, calculée avec get_pairwise, à une distribution gamma. Nous utilisons l’outil pratique fit_disc_gamma du paquet epitrix pour cette procédure d’ajustement, car nous avons besoin d’une distribution discrète.","code":"\n## générer des contacts\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## générer un objet epicontacts\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n## Estimation de l'intervalle sériel gamma\nserial_interval <- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n\n## inspecter l'estimation\nserial_interval[c(\"mu\", \"sd\")]## $mu\n## [1] 11.51047\n## \n## $sd\n## [1] 7.696056"},{"path":"epidemic_models.html","id":"projection-de-lincidence-1","chapter":"1 Modélisation des épidémies","heading":"Projection de l’incidence","text":"Pour projeter l’incidence future, nous devons fournir l’incidence historique sous la forme d’un objet incidence, ainsi qu’un échantillon de valeurs Rt plausibles. Nous générerons ces valeurs en utilisant les estimations Rt générées par EpiEstim dans la section précédente (sous “Estimation de la valeur de Rt”) et stockées dans l’objet epiestim_res_emp. Dans le code ci-dessous nous extrayons les estimations de la moyenne et de l’écart type de Rt pour la dernière fenêtre de temps de l’épidémie (en utilisant la fonction tail pour accéder au dernier élément d’un vecteur), et nous simulons 1000 valeurs à partir d’une distribution gamma en utilisant rgamma. Vous pouvez également fournir votre propre vecteur de valeurs Rt que vous souhaitez utiliser pour les projections.Nous utilisons ensuite la fonction project() pour effectuer la prévision réelle. Nous spécifions le nombre de jours pour lesquels nous voulons faire une projection via les arguments n_days, et nous spécifions le nombre de simulations en utilisant les arguments n_sim.Nous pouvons alors facilement tracer l’incidence et les projections en utilisant les fonctions plot() et add_projections(). peut facilement sous-évaluer l’objet incidence pour ne montrer que les cas les plus récents en utilisant l’opérateur de crochets.Vous pouvez également extraire facilement les estimations brutes du nombre de cas quotidiens en convertissant la sortie en un cadre de données.","code":"\n## créer un objet d'incidence à partir des dates d'apparition des symptômes\ninc <- incidence::incidence(linelist$date_onset)## 256 missing observations were removed.\n## extraire les valeurs r plausibles de l'estimation la plus récente\nmean_r <- tail(epiestim_res_emp$R$`Mean(R)`, 1)\nsd_r <- tail(epiestim_res_emp$R$`Std(R)`, 1)\nshapescale <- gamma_mucv2shapescale(mu = mean_r, cv = sd_r/mean_r)\nplausible_r <- rgamma(1000, shape = shapescale$shape, scale = shapescale$scale)\n\n## vérifier la distribution\nqplot(x = plausible_r, geom = \"histogram\", xlab = expression(R[t]), ylab = \"Counts\")## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n## faire une projection\nproj <- project(\n  x = inc,\n  R = plausible_r,\n  si = serial_interval$distribution,\n  n_days = 21,\n  n_sim = 1000\n)\n## Tracer l'incidence et les projections\nplot(inc[inc$dates > as.Date(\"2015-03-01\")]) %>%\n  add_projections(proj)\n## convertir en cadre de données pour les données brutes\nproj_df <- as.data.frame(proj)\nproj_df"},{"path":"epidemic_models.html","id":"ressources","chapter":"1 Modélisation des épidémies","heading":"1.5 Ressources","text":"Voici un article qui décrit la méthodologie mise en œuvre dans EpiEstim.\nVoici un article décrivant la méthodologie mise en œuvre dans EpiNow.\nVoici un article décrivant diverses considérations méthodologiques et pratiques pour l’estimation de Rt.","code":""}]
