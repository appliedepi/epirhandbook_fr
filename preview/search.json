[{"path":"index.html","id":"section","chapter":"","heading":"","text":"","code":""},{"path":"index.html","id":"r-pour-lépidémiologie-appliquée-et-la-santé-publique","chapter":"","heading":"R pour l’épidémiologie appliquée et la santé publique","text":"Utilisation : Ce manuel été utilisé plus d’un million de fois par 400 000 personnes dans le monde entier.Objectif: Servir de manuel de référence rapide du code R (en ligne et Télécharger le manuel et les données) avec des exemples centrés sur la tâche qui traitent des problèmes épidémiologiques courants.Essayez nos tutoriels interactifs gratuits ou notre cours d’introduction synchrone et virtuel utilisé par les CDC américains, l’OMS et plus de 130 autres agences de santé et programmes de formation à l’épidémiologie sur le terrain dans le monde entier.Langues: Anglais (English), Espagnol (Español), Vietnamien (Tiếng Việt), Japonais (日本), Turc (Türkçe), Francais, Portugais (Português)Rédigé par des épidémiologistes, pour des épidémiologistes \nApplied Epi est une organisation à non lucratif et un mouvement d’épis de première ligne du monde entier. Nous écrivons pendant notre temps libre pour offrir cette ressource à la communauté. Vos encouragements et vos commentaires sont les bienvenus :Visitez notre site web et rejoignez notre liste de contacts.contact@appliedepi.org, tweeter @appliedepi, ou LinkedInSoumettre des problèmes à notre dépôt GithubNous proposons des formations R en direct dispensées par des formateurs ayant des décennies d’expérience en épidémiologie appliquée - envoyez-nous un courriel pour en discuter.","code":""},{"path":"index.html","id":"comment-utiliser-ce-manuel","chapter":"","heading":"Comment utiliser ce manuel","text":"Parcourez les pages de la table des matières ou utilisez la boîte de recherche.Cliquez sur les icônes “copier” pour copier le code.Vous pouvez suivre avec les données d’exemple de le chapitre**.Version hors ligneVoir les instructions de la page Télécharger le manuel et les données.","code":""},{"path":"index.html","id":"remmerciements","chapter":"","heading":"Remmerciements","text":"Cet ouvrage est le fruit du travail d’une équipe internationale d’épidémiologistes, qui se sont appuyés sur leur expérience auprès d’organisations telles que les agences sanitaires locales, régionales, provinciales et nationales de divers pays, l’Organisation mondiale de la santé (OMS), Médecins Sans Frontières (MSF), les systèmes hospitaliers et les institutions universitaires.Ce guide n’est pas un produit approuvé par une organisation spécifique. Bien que nous nous soyons efforcés à être précis, nous ne pouvons fournir aucune garantie quant au contenu de ce livre.","code":""},{"path":"index.html","id":"auteurs-et-contributeurs","chapter":"","heading":"Auteurs et contributeurs","text":"Editeur: Neale BatraCommité éditorial Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay CampbellAuteurs et autrices: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen Lin, Olivia BoydRelecture: Pat Keating, Annick Lenglet, Margot Charette, Danielly Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao MuiangaIllustrations: Calder FongTraduction: Aminata Ndiaye, Anais Legrand, Marie-Amelie Degail-Chabrat, Yves Amevoin, Laura Downham, Lise Grout, Margot Charette, Mathilde Mousset, Noe Guincko, Mor Ndiaye, Elysée Junior, Nerisson Joseph, Bryan Tegomoh, Marcel Woung, Olivia Boyd, Amy Mikhail, Lucie Fournier, Paul-Evans Ehouman, Kelly McCain","code":""},{"path":"index.html","id":"financements","chapter":"","heading":"Financements","text":"Le manuel reçu un financement de soutien via une subvention d’urgence COVID-19 pour le renforcement des capacités de la part de TEPHINET, le réseau mondial des programmes de formation en épidémiologie de terrain (FETP).Le réseau des anciens d’EPIET (EAN) fourni un soutien administratif (Annika Wendland en particulier). EPIET est le programme européen de formation en épidémiologie d’intervention.Nous remercions tout particulièrement le Centre Opérationnel d’Amsterdam de Médecins Sans Frontières (MSF OCA) pour son soutien lors de l’élaboration de ce manuel.Cette publication été soutenue par l’accord de coopération numéro NU2GGH001873, financé par les Centers Disease Control Prevention par le biais de TEPHINET, un programme de “Task Force Global Health”. Son contenu relève de la seule responsabilité des auteurs et ne reflète pas les opinions officielles des Centers Disease Control Prevention, du Department Health Human Services, de Task Force Global Health, Inc. ou de TEPHINET.","code":""},{"path":"index.html","id":"inspirations","chapter":"","heading":"Inspirations","text":"Nous nous sommes inspiré de multiples tutoriels, livres et vignettes développés par la communauté pour développer ce manuel. Ces ressources, sont crédités dans les chapitres respectifs, mais nous souhaitons citer quelques sources d’inspiration générales que nous utilisons de manière récurrente :“R4Epis” project (une collaboration entre MSF et RECON)R Epidemics Consortium (RECON)R Data Science book (R4DS)bookdown: Authoring Books Technical Documents R MarkdownNetlify qui héberge ce site","code":""},{"path":"index.html","id":"conditions-dutilisation-et-contribution","chapter":"","heading":"Conditions d’utilisation et contribution","text":"","code":""},{"path":"index.html","id":"license","chapter":"","heading":"License","text":"Ce document est mis à disposition selon les termes de lalicence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International (CC -NC-SA 4.0) .N’hésitez pas à utiliser les contenus de ce manuel dans vos cours et formations en épidémiologie, ou à le conseiller à vos étudiants. Si vous avez des questions sur l’utilisation que vous souhaitez en faire, envoyez un courriel à epiRhandbook@gmail.com.","code":""},{"path":"index.html","id":"citation","chapter":"","heading":"Citation","text":"Batra, Neale, et al. Epidemiologist R Handbook. 2021. ","code":""},{"path":"index.html","id":"contribuer","chapter":"","heading":"Contribuer","text":"Si vous souhaitez contribuer à cet ouvrage, veuillez d’abord nous contacter via les tickets (issues) Github ou par courriel. Nous sommes en train de développer un calendrier de mise à jour et un guide du contributeur.Veuillez noter que le projet epiRhandbook est publié avec un code de conduite du contributeur. En contribuant à ce projet, vous acceptez de vous conformer à ses conditions.","code":""},{"path":"standardisation.html","id":"standardisation","chapter":"1 Taux standardisés","heading":"1 Taux standardisés","text":"Cette page vous montre deux façons de normaliser un résultat, tel que les hospitalisations ou la mortalité, en fonction de caractéristiques telles que l’âge et le sexe.Utilisation du paquet dsrUtilisation du paquet PHEindicatormethods.Nous commençons par démontrer de manière extensive les processus de préparation/nettoyage/jonction des données, car cela est courant lorsqu’combine des données de population provenant de plusieurs pays, des données de population standard, des décès, etc.","code":""},{"path":"standardisation.html","id":"vue-densemble","chapter":"1 Taux standardisés","heading":"1.1 Vue d’ensemble","text":"Il existe deux manières principales de normaliser : la normalisation directe et la normalisation indirecte.\nSupposons que nous voulions normaliser le taux de mortalité par âge et par sexe pour le pays et le pays B, et comparer les taux normalisés entre ces pays.Pour une standardisation directe, vous devrez connaître le nombre de personnes à risque et le nombre de décès pour chaque strate d’âge et de sexe, pour le pays et le pays B. Une strate dans notre exemple pourrait être les femmes âgées de 15 à 44 ans.Pour une standardisation indirecte, il suffit de connaître le nombre total de décès et la structure d’âge et de sexe de chaque pays. Cette option est donc envisageable si les taux de mortalité ou les chiffres de population par âge et par sexe ne sont pas disponibles. La standardisation indirecte est en outre préférable en cas de petits effectifs par strate, car les estimations en standardisation directe seraient influencées par une variation d’échantillonnage importante.","code":""},{"path":"standardisation.html","id":"préparation","chapter":"1 Taux standardisés","heading":"1.2 Préparation","text":"Pour montrer comment se fait la standardisation, nous allons utiliser des comptages fictifs de population et de décès du pays et du pays B, par âge (en catégories de 5 ans) et par sexe (femme, homme). Pour que les ensembles de données soient prêts à être utilisés, nous allons effectuer les étapes de préparation suivantes :Charger les paquetsCharger les jeux de donnéesJoignez les données de population et de décès des deux pays.Pivoter plus longtemps pour qu’il y ait une ligne par strate âge-sexe.Nettoyez la population de référence (population standard mondiale) et joignez-la aux données du pays.Dans votre scénario, vos données peuvent se présenter sous un format différent. Peut-être vos données sont-elles présentées par province, ville ou autre zone d’attraction. Vous avez peut-être une ligne pour chaque décès et des informations sur l’âge et le sexe pour chacun (ou une proportion importante) de ces décès. Dans ce cas, consultez les pages sur le Travailler sur des données groupées, Pivoter les données, Tableaux descriptifs pour créer un ensemble de données avec des comptes d’événements et de population par strate âge-sexe.Nous avons également besoin d’une population de référence, la population standard. Pour les besoins de cet exercice, nous utiliserons la world_standard_population_by_sex (population standard mondiale par sexe). La population standard mondiale est basée sur les populations de 46 pays et été développée en 1960. Il existe de nombreuses populations “standard” - à titre d’exemple, le site web de NHS Scotland est assez informatif sur la population standard européenne, la population standard mondiale et la population standard écossaise.","code":""},{"path":"standardisation.html","id":"chargement-des-paquets","chapter":"1 Taux standardisés","heading":"Chargement des paquets","text":"Ce chunk de code montre le chargement des paquets nécessaires aux analyses. Dans ce manuel, nous mettons l’accent sur p_load() de pacman, qui installe le paquet si nécessaire et le charge pour l’utiliser. Vous pouvez également charger les paquets installés avec library() de base R. Voir la page sur bases de R pour plus d’informations sur les paquets R.**ATTENTION:_** Si vous avez une version plus récente de R, le paquet dsr ne peut pas être téléchargé directement avec CRAN. Cependant, il est toujours disponible de l’archive CRAN. Vous pouvez installer et utiliser celui-ci. Pour les utilisateurs non-Mac :Pour les utilisateurs de Mac :","code":"\npacman::p_load(\n     rio, # importer/exporter des données\n     here, # localisation des fichiers\n     tidyverse, # gestion et visualisation des données\n     stringr, # nettoyage des caractères et des chaînes de caractères\n     frailtypack, # nécessaire pour dsr, pour les modèles de frailty\n     dsr, # standardiser les taux\n     PHEindicatormethods) # alternative pour la standardisation des taux\npackageurl <- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\n# Autre solution qui peut fonctionner\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"http:/cran.us.r.project.org\")\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"https://mac.R-project.org\")"},{"path":"standardisation.html","id":"charger-les-données-de-la-population","chapter":"1 Taux standardisés","heading":"Charger les données de la population","text":"Voir la page Télécharger le manuel et les données pour savoir comment télécharger tous les exemples de données du manuel. Vous pouvez importer les données de la page de normalisation directement dans R depuis notre dépôt Github en exécutant les commandes import() suivantes :Tout d’abord, nous chargeons les données démographiques (comptage des hommes et des femmes par catégorie d’âge de 5 ans) pour les deux pays que nous allons comparer, le “pays ” et le “pays B”.","code":"\n# importer les données démographiques du pays A directement depuis Github\nA_demo <- import(\"https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/country_demographics.csv\")\n\n# importer les décès pour le pays A directement depuis Github\nA_deaths <- import(\"https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/deaths_countryA.csv\")\n\n# Importez les données démographiques pour le pays B directement depuis Github.\nB_demo <- import(\"https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/country_demographics_2.csv\")\n\n# importer les décès pour le pays B directement depuis Github.\nB_deaths <- import(\"https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/deaths_countryB.csv\")\n\n# Importez les données démographiques pour le pays B directement depuis Github.\nstandard_pop_data <- import(\"https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/world_standard_population_by_sex.csv\")\n# Pays A\nA_demo <- import(\"country_demographics.csv\")\n# Pays B\nB_demo <- import(\"country_demographics_2.csv\")"},{"path":"standardisation.html","id":"chargement-du-nombre-de-morts","chapter":"1 Taux standardisés","heading":"Chargement du nombre de morts","text":"De manière pratique, nous disposons également du nombre de décès survenus pendant la période qui nous intéresse, par âge et par sexe. Les chiffres de chaque pays sont dans un fichier séparé, comme indiqué ci-dessous.Décès dans le pays ADécès dans le pays B","code":""},{"path":"standardisation.html","id":"nettoyer-les-populations-et-les-décès","chapter":"1 Taux standardisés","heading":"Nettoyer les populations et les décès","text":"Nous devons joindre et transformer ces données de la manière suivante :Combiner les populations des pays en un seul ensemble de données et faire un pivot “long” pour que chaque strate âge-sexe soit une ligne.Combiner le nombre de décès par pays dans un ensemble de données et faire pivoter “long” pour que chaque strate âge-sexe soit une ligne.Joindre les décès aux populationsTout d’abord, nous combinons les ensembles de données sur les populations des pays, nous effectuons un pivot plus long et un nettoyage mineur. Voir la page Pivoter les données pour plus de détails.Les données de population combinées ressemblent maintenant à ceci (cliquez pour voir les pays et B) :Et maintenant, nous effectuons des opérations similaires sur les deux ensembles de données de décès.Les données de décès ressemblent maintenant à ceci, et contiennent les données des deux pays :Nous joignons maintenant les données de décès et de population sur la base des colonnes communes Country, age_cat5, et Sex. Cela ajoute la colonne Deaths.Nous pouvons maintenant classer Country, age_cat5, et Sex comme facteurs et définir l’ordre des niveaux en utilisant la fonction fct_relevel() du paquet forcats, comme décrit dans la page sur Facteurs. Notez que le classement des niveaux des facteurs ne change pas visiblement les données, mais la commande arrange() les trie par Pays, catégorie d’âge et sexe.**__ATTENTION:_** Si vous avez peu de décès par strate, envisagez d’utiliser des catégories de 10, ou 15 ans, au lieu de catégories de 5 ans pour l’âge.","code":"\npop_countries <- A_demo %>% # Commencez avec l'ensemble de données du pays A\n     bind_rows(B_demo) %>% # lier les lignes, car les colonnes portent le même nom\n     pivot_longer( # pivot plus long\n          cols = c(m, f), # colonnes à combiner en une seule\n          names_to = \"Sex\", # nom de la nouvelle colonne contenant la catégorie (\"m\" ou \"f\") \n          values_to = \"Population\") %>% # nom de la nouvelle colonne contenant les valeurs numériques pivotées\n     mutate(Sex = recode(Sex, # re-code les valeurs pour plus de clarté\n          \"m\" = \"Male\",\n          \"f\" = \"Female\"))\ndeaths_countries <- A_deaths %>% # Commencez avec l'ensemble de données des décès du pays A\n     bind_rows(B_deaths) %>% # lier les lignes avec l'ensemble de données B, parce que les colonnes sont nommées de manière identique\n     pivot_longer( # pivot plus long\n          cols = c(Male, Female), # colonne à transformer en une seule\n          names_to = \"Sex\", # nom de la nouvelle colonne contenant la catégorie (\"m\" ou \"f\") \n          values_to = \"Deaths\") %>% # nom pour la nouvelle colonne contenant les valeurs numériques pivotées\n     rename(age_cat5 = AgeCat) # renomme pour plus de clarté\ncountry_data <- pop_countries %>% \n     left_join(deaths_countries, by = c(\"Country\", \"age_cat5\", \"Sex\"))\ncountry_data <- country_data %>% \n  mutate(\n    Country = fct_relevel(Country, \"A\", \"B\"),\n      \n    Sex = fct_relevel(Sex, \"Male\", \"Female\"),\n        \n    age_cat5 = fct_relevel(\n      age_cat5,\n      \"0-4\", \"5-9\", \"10-14\", \"15-19\",\n      \"20-24\", \"25-29\",  \"30-34\", \"35-39\",\n      \"40-44\", \"45-49\", \"50-54\", \"55-59\",\n      \"60-64\", \"65-69\", \"70-74\",\n      \"75-79\", \"80-84\", \"85\")) %>% \n          \n  arrange(Country, age_cat5, Sex)"},{"path":"standardisation.html","id":"chargement-de-la-population-de-référence","chapter":"1 Taux standardisés","heading":"Chargement de la population de référence","text":"Enfin, pour la standardisation directe, nous importons la population de référence (la “population standard” mondiale par sexe).","code":"\n# Population de référence\nstandard_pop_data <- import(\"world_standard_population_by_sex.csv\")"},{"path":"standardisation.html","id":"nettoyer-la-population-de-référence","chapter":"1 Taux standardisés","heading":"Nettoyer la population de référence","text":"Les valeurs des catégories d’âge dans les cadres de données country_data et standard_pop_data devront être alignées.Actuellement, les valeurs de la colonne age_cat5 du cadre de données standard_pop_data contiennent le mot “years” et “plus”, alors que celles du cadre de données country_data ne le font pas. Nous devrons faire correspondre les valeurs des catégories d’âge. Nous utilisons str_replace_all() du paquet stringr, comme décrit dans la page Caractères et chaînes de caractères, pour remplacer ces motifs par des \"\" sans espace.De plus, le paquet dsr s’attend à ce que dans la population standard, la colonne contenant les comptes soit appelée \"pop\". Nous renommons donc cette colonne en conséquence.CAUTION: Si vous essayez d’utiliser str_replace_all() pour supprimer un symbole plus, cela ne fonctionnera pas car c’est un symbole spécial. “Échappez” au spécial en mettant deux barres obliques inverses devant, comme dans str_replace_call(column, \"\\\\+\", \"\"). ","code":"\n# Suppression d'une chaîne spécifique des valeurs de la colonne\nstandard_pop_clean <- standard_pop_data %>%\n     mutate(\n          age_cat5 = str_replace_all(age_cat5, \"years\", \"\"), # supprime \"year\" (année)\n          age_cat5 = str_replace_all(age_cat5, \"plus\", \"\"), # supprimez \"plus\".\n          age_cat5 = str_replace_all(age_cat5, \" \", \"\")) %>% # supprime l'espace \" \".\n     \n     rename(pop = WorldStandardPopulation) # change le nom de la colonne en \"pop\", car cela est attendu par le paquet dsr"},{"path":"standardisation.html","id":"standard_all","chapter":"1 Taux standardisés","heading":"1.2.1 Créer un jeu de données avec une population standard","text":"Enfin, le package PHEindicatormethods, détaillé ci-dessous, attend les populations standards jointes aux événements et aux comptages de population du pays. Nous allons donc créer un jeu de données all_data à cet effet.Cet ensemble de données complet ressemble à ceci :","code":"\nall_data <- left_join(country_data, standard_pop_clean, by=c(\"age_cat5\", \"Sex\"))"},{"path":"standardisation.html","id":"dsr-package","chapter":"1 Taux standardisés","heading":"1.3 dsr package","text":"Nous démontrons ci-dessous le calcul et la comparaison de taux directement standardisés à l’aide du package dsr. Le package dsr vous permet de calculer et de comparer des taux directement standardisés (pas de taux indirectement standardisés !).Dans la section Préparation des données, nous avons créé des jeux de données distincts pour le nombre de pays et la population standard :l’objet country_data, qui est un tableau de population avec le nombre de population et le nombre de décès par strate par paysl’objet standard_pop_clean, contenant le nombre de personnes par strate pour notre population de référence, la population standard mondiale.Nous utiliserons ces ensembles de données distincts pour l’approche dsr.","code":""},{"path":"standardisation.html","id":"taux-standardisés","chapter":"1 Taux standardisés","heading":"Taux standardisés","text":"Ci-dessous, nous calculons les taux par pays directement standardisés pour l’âge et le sexe. Nous utilisons la fonction dsr().noter - dsr() s’attend à un cadre de données pour les populations des pays et le nombre d’événements (décès), et un autre cadre de données avec la population de référence. Il s’attend également à ce que dans cette base de données de la population de référence, le nom de la colonne unité-temps soit “pop” (nous nous en sommes assurés dans la section Préparation des données).Il y de nombreux arguments, comme annoté dans le code ci-dessous. Notamment, event = est fixé à la colonne Deaths, et le fu = (“follow-”) est fixé à la colonne Population. Nous définissons les sous-groupes de comparaison comme la colonne Country et nous standardisons sur la base de age_cat5 et Sex. Ces deux dernières colonnes n’ont pas d’argument nommé particulier. Voir ?dsr pour plus de détails.Ci-dessus, nous voyons que même si le pays avait un taux de mortalité brut plus faible que le pays B, il un taux standardisé plus élevé après standardisation directe par âge et par sexe.","code":"\n# Calculez les taux par pays directement standardisés pour l'âge et le sexe\nmortality_rate <- dsr::dsr(\n     data = country_data, # spécifier l'objet contenant le nombre de décès par strate\n     event = Deaths, # colonne contenant le nombre de décès par strate \n     fu = Population, # colonne contenant le nombre de population par strate\n     subgroup = Country, # unités que nous souhaitons comparer\n     age_cat5, # autres colonnes - les taux seront standardisés par celles-ci\n     Sex,\n     refdata = standard_pop_clean, # cadre de données de la population de référence, avec une colonne appelée \"pop\".\n     method = \"gamma\", # méthode pour calculer l'IC à 95%.\n     sig = 0,95, # niveau de signification\n     mp = 100000, # nous voulons les taux pour 100.000 habitants\n     decimals = 2) # nombre de décimales)\n\n\n# Imprimez la sortie sous la forme d'un joli tableau HTML\nknitr::kable(mortality_rate) # Afficher le taux de mortalité avant et après la standardisation directe"},{"path":"standardisation.html","id":"ratios-de-taux-standardisés","chapter":"1 Taux standardisés","heading":"Ratios de taux standardisés","text":"Le taux de mortalité standardisé est 1,22 fois plus élevé dans le pays que dans le pays B (IC 95 % 1.17-1.27).","code":"\n# Calculer le RR\nmortality_rr <- dsr::dsrr(\n     data = country_data, # spécifier l'objet contenant le nombre de décès par strate\n     event = Deaths, # colonne contenant le nombre de décès par strate \n     fu = Population, # colonne contenant le nombre de population par strate\n     subgroup = Country, # unités que nous souhaitons comparer\n     age_cat5,\n     Sex, # caractéristiques sur lesquelles nous aimerions nous standardiser \n     refdata = standard_pop_clean, # population de référence, avec des chiffres dans la colonne appelée pop\n     refgroup = \"B\", # référence pour la comparaison\n     estimate = \"ratio\", # type d'estimation\n     sig = 0.95, # niveau de signification\n     mp = 100000, # nous voulons des taux pour 100.000 habitants\n     decimals = 2) # nombre de décimales\n\n# Imprimer le tableau\nknitr::kable(mortality_rr) "},{"path":"standardisation.html","id":"différence-de-taux-standardisé","chapter":"1 Taux standardisés","heading":"Différence de taux standardisé","text":"Le pays 4.24 décès supplémentaires pour 100.000 habitants (IC 95% 3.24-5.24) par rapport au pays .","code":"\n# Calculer RD\nmortality_rd <- dsr::dsrr(\n     data = country_data, # spécifier l'objet contenant le nombre de décès par strate\n     event = Deaths, # colonne contenant le nombre de décès par strate \n     fu = Population, # colonne contenant le nombre de population par strate\n     subgroup = Country, # unités que nous souhaitons comparer\n     age_cat5, # caractéristiques sur lesquelles nous voulons nous standardiser\n     Sex,                        \n     refdata = standard_pop_clean, # population de référence, avec des chiffres dans la colonne appelée pop\n     refgroup = \"B\", # référence pour la comparaison\n     estimate = \"difference\", # type d'estimation\n     sig = 0.95, # niveau de signification\n     mp = 100000, # nous voulons des taux pour 100.000 habitants\n     decimals = 2) # nombre de décimales\n\n# Imprimer le tableau\nknitr::kable(mortality_rd) "},{"path":"standardisation.html","id":"standard_phe","chapter":"1 Taux standardisés","heading":"1.4 PHEindicatormethods package","text":"Une autre façon de calculer les taux standardisés est avec le paquet PHEindicatormethods. Ce package vous permet de calculer les taux standardisés directement et indirectement. Nous allons montrer les deux.Cette section utilisera le cadre de données all_data créé à la fin de la section Préparation. Ce cadre de données inclut les populations des pays, les événements de décès, et la population de référence standard mondiale. Vous pouvez le visualiser ici.","code":""},{"path":"standardisation.html","id":"taux-directement-standardisés","chapter":"1 Taux standardisés","heading":"Taux directement standardisés","text":"Ci-dessous, nous regroupons d’abord les données par Pays, puis nous les passons à la fonction phe_dsr() pour obtenir les taux directement standardisés par pays.noter - la population de référence (standard) peut être fournie comme une colonne dans le cadre de données spécifique au pays ou comme un vecteur séparé. Si elle est fournie dans le cadre de données spécifique au pays, vous devez définir stdpoptype = \"field\". Si elle est fournie sous forme de vecteur, définissez stdpoptype = \"vector\". Dans ce dernier cas, vous devez vous assurer que l’ordre des rangées par strate est similaire dans le cadre de données spécifique au pays et dans la population de référence, car les enregistrements seront appariés par position. Dans notre exemple ci-dessous, nous avons fourni la population de référence sous forme de colonne dans le cadre de données spécifique au pays.Consultez l’aide de ?phe_dsr ou les liens dans la section Références pour plus d’informations.","code":"\n# Calculez les taux par pays directement normalisés pour l'âge et le sexe.\nmortality_ds_rate_phe <- all_data %>%\n     group_by(Country) %>%\n     PHEindicatormethods::phe_dsr(\n          x = Deaths, # colonne avec le nombre d'événements observés\n          n = Population, # colonne avec les pops non standard pour chaque strate\n          stdpop = pop, # populations standard pour chaque strate\n          stdpoptype = \"field\")       # soit \"vector\" pour un vecteur autonome, soit \"field\" pour signifier que les populations std sont dans les données.  \n\n# Imprimer le tableau\nknitr::kable(mortality_ds_rate_phe)"},{"path":"standardisation.html","id":"standard_indirect","chapter":"1 Taux standardisés","heading":"Taux standardisés indirectement","text":"Pour la standardisation indirecte, vous avez besoin d’une population de référence avec le nombre de décès et le nombre de population par strate. Dans cet exemple, nous allons calculer les taux pour le pays en utilisant le pays B comme population de référence, car la population de référence standard_pop_clean n’inclut pas le nombre de décès par strate.Ci-dessous, nous créons d’abord la population de référence du pays B. Ensuite, nous passons les données de mortalité et de population pour le pays , nous les combinons avec la population de référence, et nous les passons à la fonction phe_isr(), pour obtenir des taux indirectement standardisés. Bien sûr, vous pouvez aussi faire l’inverse.noter - dans notre exemple ci-dessous, la population de référence est fournie comme un cadre de données séparé. Dans ce cas, nous nous assurons que les vecteurs x =, n =, x_ref = et n_ref = sont tous ordonnés par les mêmes valeurs de catégorie de standardisation (strate) que celles de notre cadre de données spécifique au pays, puisque les enregistrements seront appariés par position.Consultez l’aide de ?phe_isr (maintenant calculate_ISRate depuis dec 2022) ou les liens dans la section Références pour plus d’informations.","code":"\n# Créez la population de référence\nrefpopCountryB <- country_data %>% \n  filter(Country == \"B\") \n\n# Calculer les taux pour le pays A indirectement standardisés par âge et sexe\nmortality_is_rate_phe_A <- country_data %>%\n     filter(Country == \"A\") %>%\n     PHEindicatormethods::calculate_ISRate( #avant c'etait phe_isr()\n          x = Deaths, # colonne avec le nombre d'événements observés\n          n = Population, # colonne avec les pops non standard pour chaque strate\n          x_ref = refpopCountryB$Deaths, # nombre de décès de référence pour chaque strate\n          n_ref = refpopCountryB$Population) # population de référence pour chaque strate\n\n# Imprimez le tableau\nknitr::kable(mortality_is_rate_phe_A)"},{"path":"standardisation.html","id":"ressources","chapter":"1 Taux standardisés","heading":"1.5 Ressources","text":"Si vous souhaitez voir un autre exemple reproductible utilisant dsr, veuillez consulter cette vignette.Pour un autre exemple utilisant PHEindicatormethods, veuillez vous rendre sur ce site WebVoir les PHEindicatormethods fichier pdf de référence","code":""},{"path":"download_book_data.html","id":"download_book_data","chapter":"2 Télécharger le manuel et les données","heading":"2 Télécharger le manuel et les données","text":"","code":""},{"path":"download_book_data.html","id":"download_offline","chapter":"2 Télécharger le manuel et les données","heading":"2.1 Télécharger le manuel hors-ligne","text":"Vous pouvez télécharger la version hors-ligne de ce manuel en tant que fichier HTML afin de pouvoir le visualiser dans votre navigateur Web même si vous n’avez plus accès à Internet. Si vous envisagez d’utiliser le manuel Epi R hors ligne, voici quelques éléments à prendre en compte :Lorsque vous ouvrez le fichier, le chargement des images et de la table des matières peut prendre une minute ou deux.Le manuel hors ligne une mise en page légèrement différente : une très longue page avec la table des matières à gauche. Pour rechercher des termes spécifiques, utilisez Ctrl + F (Cmd + F).Consultez la page Paquets conseillés pour vous aider à installer les paquets R appropriés avant de perdre votre connexion à Internet.Installez notre paquet R epirhandbook qui contient toutes les données utilisées dans les exemples (le processus d’installation est décrit ci-dessous).Il y deux façons de télécharger le manuel :","code":""},{"path":"download_book_data.html","id":"utiliser-le-lien-de-téléchargement","chapter":"2 Télécharger le manuel et les données","heading":"Utiliser le lien de téléchargement","text":"Pour un accès rapide, cliquez à droite ce lien et sélectionnez “Enregistrer le lien sous”.Si vous êtes sur un Mac, utilisez Cmd + clic. Si vous êtes sur un téléphone portable, appuyez sur le lien et maintenez-le enfoncé, puis sélectionnez “Enregistrer le lien”. Le manuel sera téléchargé sur votre appareil. Si un écran contenant un code HTML brut apparaît, assurez-vous d’avoir suivi les instructions ci-dessus ou essayez l’option 2.","code":""},{"path":"download_book_data.html","id":"utiliser-notre-paquet-r","chapter":"2 Télécharger le manuel et les données","heading":"Utiliser notre paquet R","text":"Nous avons développé un paquet R appelé epirhandbook. Il comprend une fonction download_book() qui télécharge le fichier du guide depuis notre dépôt Github sur votre ordinateur.Ce package contient également une fonction get_data() qui télécharge toutes les données utilisées dans les chapitres sur votre ordinateur.Exécutez le code suivant pour installer notre paquet R epirhandbook à partir du dépôt Github appliedepi. Ce paquet n’est pas sur le CRAN, donc utilisez la fonction spéciale p_install_gh() du paquet pacman pour l’installer depuis Github.Maintenant, importer le paquet pour l’utiliser dans votre session R actuelle :Ensuite, exécutez la fonction du paquet download_book() (avec des parenthèses vides) pour télécharger le manuel sur votre ordinateur. En supposant que vous êtes dans RStudio, une fenêtre apparaîtra pour vous permettre de sélectionner un emplacement de sauvegarde.","code":"\n# installer la dernière version du paquet epirhandbook\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n# Importer le paquet pour pouvoir l'utiliser dans la session ouverte\npacman::p_load(epirhandbook)\n# télécharger la version html du manuel localement\ndownload_book()"},{"path":"download_book_data.html","id":"télécharger-les-données","chapter":"2 Télécharger le manuel et les données","heading":"2.2 Télécharger les données","text":"Pour pouvoir reproduire les exemples au fur et à mesure sur votre ordinateur, vous pouvez télécharger les données et les fichiers générés.","code":""},{"path":"download_book_data.html","id":"utiliser-notre-paquet-r-1","chapter":"2 Télécharger le manuel et les données","heading":"Utiliser notre paquet R","text":"Une fois le paquet téléchargé et importé dans votre session R (voir section au-dessus) utilisez la fonction get_data() du paquet pour obtenir les données d’exemple sur votre ordinateur. Exécutez get_data(\"\") pour obtenir toutes les données d’exemple, ou fournissez un nom de fichier spécifique et une extension entre guillemets pour récupérer un seul fichier.Techniquement, toutes les données ont déjà été téléchargées avec le paquet, et doivent simplement être transférées dans un dossier de votre ordinateur. Une fenêtre pop-apparaîtra, vous permettant de sélectionner un emplacement de dossier de sauvegarde. Nous vous suggérons de créer un nouveau dossier “data” car il y environ 30 fichiers (y compris les données d’exemple et les sorties générées par les exemples).Une fois que vous avez utilisé get_data() pour enregistrer un fichier sur votre ordinateur, vous devrez encore l’importer dans R. Voir la page Importer et exporter des données pour plus de détails.Si vous le souhaitez, vous pouvez consulter toutes les données utilisées dans ce manuel dans le “dossier données” de notre dépôt Github.","code":"\n# enregistrer toutes les données dans un dossier sur votre ordinateur\nget_data(\"all\")\n\n# enregistrer les données linelist dans un dossiet sur votre ordinateur\nget_data(file = \"linelist_cleaned.rds\")"},{"path":"download_book_data.html","id":"téléchargement-manuel","chapter":"2 Télécharger le manuel et les données","heading":"Téléchargement manuel","text":"Vous pouvez télécharger les données fichier par fichier à partir de notre dépôt Github via un lien ou une commande R spécifique au fichier. Certains types de fichiers ont un bouton de téléchargement, tandis que d’autres peuvent être téléchargés via une commande R.","code":""},{"path":"download_book_data.html","id":"liste-de-cas-linelist","chapter":"2 Télécharger le manuel et les données","heading":"Liste de cas (linelist)","text":"Il s’agit d’une linelist pour une épidémie d’Ebola fictive, développée par notre équipe à partir du jeu de données d’exemple ebola_sim du paquet outbreaks.Cliquer pour télécharger les données brutes (.xlsx). La liste de cas “brute” est une feuille de calcul Excel contenant des données désordonnées. Utilisez-la pour suivre la page Nettoyer les données et fonctions essentielles.Cliquer pour télécharger les données brutes (.xlsx). La liste de cas “brute” est une feuille de calcul Excel contenant des données désordonnées. Utilisez-la pour suivre la page Nettoyer les données et fonctions essentielles.Cliquer pour télécharger la linelist nettoyée (.rds). Utilisez ce fichier pour toutes les autres pages de ce manuel qui utilisent la linelist. Un fichier .rds est un type de fichier spécifique à R qui préserve les classes de colonnes. Cela garantit que vous n’aurez qu’un nettoyage minimal à faire après avoir importé les données dans R.Cliquer pour télécharger la linelist nettoyée (.rds). Utilisez ce fichier pour toutes les autres pages de ce manuel qui utilisent la linelist. Un fichier .rds est un type de fichier spécifique à R qui préserve les classes de colonnes. Cela garantit que vous n’aurez qu’un nettoyage minimal à faire après avoir importé les données dans R.Autres fichiers linelist :Cliquer pour télécharger la version nettoyée de la linelist sous format ExcelCliquer pour télécharger la version nettoyée de la linelist sous format ExcelUne partie de la page sur le nettoyage des données utilise un “dictionnaire de nettoyage” (fichier .csv). Vous pouvez le charger directement dans R en exécutant les commandes suivantes :Une partie de la page sur le nettoyage des données utilise un “dictionnaire de nettoyage” (fichier .csv). Vous pouvez le charger directement dans R en exécutant les commandes suivantes :","code":"\npacman::p_load(rio) # installer/importer le paquet **rio**\n\n# importer le fichier directement depuis github\ncleaning_dict <- import(\"https://github.com/appliedepi/epiRhandbook_fr/tree/master/data/case_linelists/cleaning_dict.csv\")"},{"path":"download_book_data.html","id":"data_malaria","chapter":"2 Télécharger le manuel et les données","heading":"Cas de paludisme","text":"Ces données sont des comptages fictifs de cas de paludisme par groupe d’âge, établissement et jour. Un fichier .rds est un type de fichier spécifique à R qui préserve les classes de colonnes. Cela garantit que vous n’aurez qu’un nettoyage minimal à faire après avoir importé les données dans R.\nClick download\nles comptages de de cas de paludisme (.rds file)\n","code":""},{"path":"download_book_data.html","id":"données-sur-léchelle-de-likert","chapter":"2 Télécharger le manuel et les données","heading":"Données sur l’échelle de Likert","text":"Il s’agit de données fictives issues d’une enquête de type Likert, utilisées dans la page Pyramides démographiques et échelles de Likert. Vous pouvez charger ces données directement dans R en exécutant les commandes suivantes :","code":"\npacman::p_load(rio)  # installer/importer le paquet **rio**\n\n# importer le fichier directement depuis github\nlikert_data <- import(\"https://github.com/appliedepi/epiRhandbook_fr/tree/master/data/likert_data.csv\")"},{"path":"download_book_data.html","id":"flexdashboard","chapter":"2 Télécharger le manuel et les données","heading":"Flexdashboard","text":"Vous trouverez ci-dessous des liens vers le fichier associé à la page Tableaux de bord avec R Markdown:Pour télécharger le fichier RMarkdown (.Rmd) du tableau de bord sur les épidémies, faites un clic droit sur ce lien (Cmd+clic pour Mac) et sélectionnez “Enregistrer le lien sous”.Pour télécharger le tableau de bord HTML, cliquez avec le bouton droit de la souris sur ce lien. (Cmd + clic pour Mac) et sélectionnez “Enregistrer le lien sous”.","code":""},{"path":"download_book_data.html","id":"recherche-des-contacts","chapter":"2 Télécharger le manuel et les données","heading":"recherche des contacts","text":"La page Recherche des contacts présente une analyse des données de recherche des contacts, à l’aide d’exemples de données provenant de Go.Data. Les données utilisées dans cette page peuvent être téléchargées sous forme de fichiers .rds en cliquant sur les liens suivants :\nCliquer pour télécharger\nles données d’investigation des cas (.rds file)\n\nCliquer pour télécharger\nles données d’enregistrement des contacts (.rds file)\n\nCliquer pour télécharger\nles données de suivi des contacts (.rds file)\nNOTE: Les données structurées de recherche des contacts provenant d’autres logiciels (par exemple KoBo, DHIS2 Tracker, CommCare) peuvent être organisées differement. Si vous souhaitez contribuer à l’élaboration d’un échantillon de données ou d’un contenu alternatif pour cette page, veuillez nous contacter.TIP: Si vous déployez Go.Data et souhaitez vous connecter à l’API de votre instance, consultez la page Importation et exportation, (section API) et la Communauté de pratique Go.Data.","code":""},{"path":"download_book_data.html","id":"sig","chapter":"2 Télécharger le manuel et les données","heading":"SIG","text":"Les fichiers Shapefiles comportent de nombreux sous-fichiers, chacun avec une extension de fichier différente. Un fichier aura l’extension “.shp”, mais d’autres peuvent avoir “.dbf”, “.prj”, etc.La page Notions de base sur les SIG fournit des liens vers le site Web Humanitarian Data Exchange où vous pouvez télécharger les fichiers de forme directement sous forme de fichiers zippés.Par exemple, les données des locations des établissements de santé peuvent être téléchargées ici. Téléchargez “hotosm_sierra_leone_health_facilities_points_shp.zip”. Une fois enregistré sur votre ordinateur, décompressez le dossier. Vous verrez plusieurs fichiers avec des extensions différentes (par exemple, “.shp”, “.prj”, “.shx”); tous ces fichiers doivent être enregistrés dans le même dossier sur votre ordinateur. Ensuite, pour importer dans R, fournissez le chemin et le nom du fichier “.shp” à st_read() du paquet sf (comme décrit dans la page Notions de base sur les SIG).Si vous suivez l’option 1 pour télécharger toutes les données de l’exemple (via notre paquet R epirhandbook), tous les shapefiles sont inclus.Vous pouvez également télécharger les fichiers Shapefile à partir du dossier “data” du manuel R sur Github (voir le sous-dossier “gis”). Cependant, sachez que vous devrez télécharger chaque sous-fichier individuellement sur votre ordinateur. Dans Github, cliquez sur chaque fichier et téléchargez-les en cliquant sur le bouton “Télécharger”. Ci-dessous, vous pouvez voir comment le fichier de forme “sle_adm3” se compose de plusieurs fichiers, chacun devant être téléchargé depuis Github.","code":""},{"path":"download_book_data.html","id":"arbres-phylogénétiques","chapter":"2 Télécharger le manuel et les données","heading":"Arbres phylogénétiques","text":"La page sur les arbres phylogénétiques utilise un fichier Newick pour l’arbre phylogénétique construit à partir du séquençage du génome entier de 299 échantillons de Shigella sonnei et des données d’échantillons correspondantes (converties en fichier texte). Les échantillons belges et les données résultantes sont aimablement fournis par le CNR belge pour Salmonella et Shigella dans le cadre d’un projet mené par un boursier EUPHEM de l’ECDC, et seront également publiés dans un manuscrit. Les données internationales sont disponibles sur des bases de données publiques (ncbi) et ont déjà été publiées.Pour télécharger le fichier de l’arbre phylogénétique “Shigella_tree.txt”, cliquez avec le bouton droit de la souris sur ce lien (Cmd+click Mac) et sélectionnez “Enregistrer le lien sous”.Pour télécharger le fichier “sample_data_Shigella_tree.csv” contenant des informations supplémentaires sur chaque échantillon, cliquez avec le bouton droit de la souris sur ce lien (Cmd+clic pour Mac) et sélectionnez “Enregistrer le lien sous”.Pour voir le nouveau sous-arbre créé, cliquez avec le bouton droit de la souris sur ce lien (Cmd+clic pour Mac) et sélectionnez “Enregistrer le lien sous”. Le fichier .txt sera téléchargé sur votre ordinateur.Vous pouvez ensuite importer les fichiers .txt avec read.tree() du paquet ape, comme expliqué dans le chapitre concerné.","code":"\nape::read.tree(\"Shigella_tree.txt\")"},{"path":"download_book_data.html","id":"standardization","chapter":"2 Télécharger le manuel et les données","heading":"Standardization","text":"Pour la page sur la standardisation des données, vous pouvez charger les données directement depuis notre dépôt Github sur internet dans votre session R avec les commandes suivantes :","code":"\n# installer/importer le paquet **rio**\npacman::p_load(rio) \n\n##############\n# Pays A\n##############\n# import des données démographiques du pays depuis github\nA_demo <- import(\"https://github.com/appliedepi/epiRhandbook_fr/tree/master/data/standardization/country_demographics.csv\")\n\n# import des données de mortalité du pays depuis github\nA_deaths <- import(\"https://github.com/appliedepi/epiRhandbook_fr/tree/master/data/standardization/deaths_countryA.csv\")\n\n\n\n##############\n# Pays B\n##############\n# import des données démographiques du pays depuis github\nB_demo <- import(\"https://github.com/appliedepi/epiRhandbook_fr/tree/master/data/standardization/country_demographics_2.csv\")\n\n# import des données de mortalité du pays depuis github\nB_deaths <- import(\"https://github.com/appliedepi/epiRhandbook_fr/tree/master/data/standardization/deaths_countryB.csv\")\n\n\n###############\n# Population de référence\n###############\n# import depuis Github\nstandard_pop_data <- import(\"https://github.com/appliedepi/epiRhandbook_fr/tree/master/data/standardization/world_standard_population_by_sex.csv\")"},{"path":"download_book_data.html","id":"data_outbreak","chapter":"2 Télécharger le manuel et les données","heading":"Séries temporelles et détection des épidémies","text":"Voir la page sur les séries temporelles et la détection des épidémies. Nous utilisons les cas de campylobacter rapportés en Allemagne de 2002 à 2011, tels que disponibles dans le paquet R surveillance. (note cet ensemble de données été adapté de l’original, en ce sens que 3 mois de données ont été supprimés à partir de la fin de 2011 à des fins de démonstration).\nCliquer pour télécharger\n Campylobacter en Allemagne (.xlsx)\nNous utilisons également les données climatiques de l’Allemagne entre 2002 et 2011 (température en degrés Celsius et précipitations en millimètres). Ces données ont été téléchargées à partir d’un jeu de données dérivé des données produites par le satellite Copernicus (UE) à l’aide du paquet ecmwfr. Vous devrez télécharger toutes ces données et les importer avec stars::read_stars() comme expliqué dans la page sur les séries temporelles.\nCliquer pour télécharger\n Climat Allemagne 2002 (.nc file)\n\nCliquer pour télécharger\n Climat Allemagne 2003 (.nc file)\n\nCliquer pour télécharger\n Climat Allemagne 2004 (.nc file)\n\nCliquer pour télécharger\n Climat Allemagne 2005 (.nc file)\n\nCliquer pour télécharger\n Climat Allemagne 2006 (.nc file)\n\nCliquer pour télécharger\n Climat Allemagne 2007 (.nc file)\n\nCliquer pour télécharger\n Climat Allemagne 2008 (.nc file)\n\nCliquer pour télécharger\n Climat Allemagne 2009 (.nc file)\n\nCliquer pour télécharger\n Climat Allemagne 2010 (.nc file)\n\nCliquer pour télécharger\n Climat Allemagne 2011 (.nc file)\n","code":""},{"path":"download_book_data.html","id":"data_survey","chapter":"2 Télécharger le manuel et les données","heading":"Analyse d’enquêtes","text":"Pour la page analyse d’enquête, nous utilisons des données d’enquêtes de mortalité fictives basées sur les modèles d’enquête MSF OCA. Ces données fictives ont été générées dans le cadre du projet “R4Epis”.\nCliquer pour télécharger\n Données d’enquête fictives (.xlsx)\n\nCliquer pour télécharger\n Données d’enquête fictives (dictionnaire) (.xlsx)\n\nCliquer pour télécharger\n Données d’enquête fictives (données de population) (.xlsx)\n","code":""},{"path":"download_book_data.html","id":"data_shiny","chapter":"2 Télécharger le manuel et les données","heading":"Shiny","text":"La page sur les tableaux de bord avec Shiny illustre la construction d’une application simple pour afficher les données sur le paludisme.Pour télécharger les fichiers R qui produisent l’app Shiny :Vous pouvez \ncliquer ici pour télécharger le fichier app.R qui contient à la fois le code de l’interface utilisateur et du serveur pour l’application Shiny..Vous pouvez \ncliquer ici pour télécharger le fichier facility_count_data.rds qui contient les données sur le paludisme pour l’application Shiny. Notez que vous devrez peut-être l’enregistrer dans un dossier “data” pour que les chemins de fichier () fonctionnent correctement.Vous pouvez \ncliquer ici pour télécharger le fichier global.R qui doit être exécuté avant l’ouverture de l’app, comme expliqué dans la page.Vous pouvez \ncliquer ici pour télécharger le fichier plot_epicurve.R dont l’exécution est lancée par le script global.R. Notez que vous devrez peut-être le stocker dans un dossier “funcs” pour que les chemins de fichier () fonctionnent correctement.","code":""},{"path":"transmission_chains.html","id":"transmission_chains","chapter":"3 Chaînes de transmission","heading":"3 Chaînes de transmission","text":"","code":""},{"path":"transmission_chains.html","id":"aperçu","chapter":"3 Chaînes de transmission","heading":"3.1 Aperçu","text":"L’outil principal pour manipuler, analyser, et visualiser les chaînes de transmission et les données de recherche de contact est le paquet epicontacts, développé par RECON. Essayez le graphique interactif ci-dessous en passant la souris sur les noeuds pour obtenir plus d’informations et en cliquant dessus pour surligner les cas descendants.","code":""},{"path":"transmission_chains.html","id":"préparation-1","chapter":"3 Chaînes de transmission","heading":"3.2 Préparation","text":"","code":""},{"path":"transmission_chains.html","id":"charger-les-paquets","chapter":"3 Chaînes de transmission","heading":"Charger les paquets","text":"Commencez par charger les paquets standards nécessaires à l’importation et à la manipulation des données. Dans ce manuel, nous mettons l’accent sur p_load() de pacman, qui installe le paquet si nécessaire et le charge pour l’utiliser. Vous pouvez également charger des paquets avec library() de base R. Voir la page sur bases de R pour plus d’informations sur les paquets R.Vous aurez besoin de la version de développement de epicontacts, qui peut être installée de github en utilisant la fonction p_install_github() de pacman. Vous n’avez besoin d’exécuter cette commande ci-dessous qu’une seule fois, et pas à chaque fois que vous utilisez le paquet (par la suite, vous pouvez utiliser p_load() comme d’habitude).","code":"\npacman::p_load(\n   rio, # Importation de fichiers\n   here, # Localisation de fichiers\n   tidyverse, # Gestion des données + graphiques ggplot2\n   remotes # Installation de paquets depuis github\n)\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")"},{"path":"transmission_chains.html","id":"importer-les-données","chapter":"3 Chaînes de transmission","heading":"Importer les données","text":"Nous importons le jeu de données des cas d’une épidémie d’Ebola simulée. Si vous souhaitez télécharger les données pour suivre le code, consultez les instructions de la page Télécharger le manuel et les données. Le jeu de données est importé à l’aide de la fonction import() du paquet rio. Voir la page Importation et exportation pour connaître les différentes methodes d’importer des données.Les 50 premières lignes de la linelist sont affichées ci-dessous. Les colonnes case_id, generation, infector, et source sont particulièrement intéressantes.","code":"\n# Importez la liste de cas\nlinelist <- import(\"linelist_cleaned.xlsx\")"},{"path":"transmission_chains.html","id":"création-dun-objet-epicontacts","chapter":"3 Chaînes de transmission","heading":"Création d’un objet epicontacts","text":"Nous devons ensuite créer un objet epicontacts, qui nécessite deux types de données:une linelist documentant les cas où les colonnes sont des variables et les lignes correspondent à des cas uniques.une liste de bords définissant les liens entre les cas sur la base de leurs identifiants uniques (il peut s’agir de contacts,\ndes événements de transmission, etc.)Comme nous avons déjà une linelist, il nous suffit de créer une liste de bord entre les cas, plus précisément entre leurs ID. Nous pouvons extraire les liens de transmission de la linelist en liant la colonne infector avec la colonne case_id. ce stade, nous pouvons également ajouter des “propriétés de bords”, c’est-à-dire toute variable décrivant le lien entre les deux cas, mais pas les cas eux-mêmes. Pour illustration, nous allons ajouter une variable location décrivant l’emplacement de l’événement de transmission, et une variable duration (durée) décrivant la durée du contact en jours.Dans le code ci-dessous, la fonction transmute de le paquet dplyr est similaire à mutate, sauf qu’elle ne conserve que les colonnes que nous avons spécifiées dans la fonction. La fonction drop_na enlevera toutes les lignes où les colonnes spécifiées ont une valeur NA. Dans ce cas, nous ne voulons conserver que les lignes où l’infecteur est connu.Nous pouvons maintenant créer l’objet epicontacts en utilisant la fonction make_epicontacts . Nous devons spécifier quelle colonne de la linelist correspond à l’identifiant unique du cas, ainsi que les colonnes des contacts qui pointent vers les identifiants uniques des cas impliqués dans chaque lien. Ces liens sont directionnels en le sens que l’infection va de l’infecteur à le cas, les arguments et en conséquence. Nous définissons donc l’argument directed (direction) à TRUE (VRAI), ce qui affectera les opérations futures.En examinant les objets epicontacts, peut voir que la colonne case_id de la linelist été renommée à id et que les colonnes case_id et infector des contacts ont été renommées à et . Cela garantit la cohérence dans le traitement, visualisation et analyse de l’objet epicontacts.","code":"\n## générer des contacts\ncontacts <- linelist %>%\n  transmute(\n    infector = infector,\n    case_id = case_id,\n    location = sample(c(\"Community\", \"Nosocomial\"), n(), TRUE),\n    duration = sample.int(10, n(), TRUE)\n  ) %>%\n  drop_na(infector)\n## générer un objet epicontacts\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts,\n  id = \"case_id\",\n  from = \"infector\",\n  to = \"case_id\",\n  directed = TRUE\n)\n## visualiser l'objet epicontacts\nepic## \n## /// Epidemiological Contacts //\n## \n##   // class: epicontacts\n##   // 5,888 cases in linelist; 3,800 contacts; directed \n## \n##   // linelist\n## \n## # A tibble: 5,888 × 30\n##    id     generation date_infection date_onset date_hospitalisation date_outcome outcome gender\n##    <chr>       <dbl> <date>         <date>     <date>               <date>       <chr>   <chr> \n##  1 5fe599          4 2014-05-08     2014-05-13 2014-05-15           NA           <NA>    m     \n##  2 8689b7          4 NA             2014-05-13 2014-05-14           2014-05-18   Recover f     \n##  3 11f8ea          2 NA             2014-05-16 2014-05-18           2014-05-30   Recover m     \n##  4 b8812a          3 2014-05-04     2014-05-18 2014-05-20           NA           <NA>    f     \n##  5 893f25          3 2014-05-18     2014-05-21 2014-05-22           2014-05-29   Recover m     \n##  6 be99c8          3 2014-05-03     2014-05-22 2014-05-23           2014-05-24   Recover f     \n##  7 07e3e8          4 2014-05-22     2014-05-27 2014-05-29           2014-06-01   Recover f     \n##  8 369449          4 2014-05-28     2014-06-02 2014-06-03           2014-06-07   Death   f     \n##  9 f393b4          4 NA             2014-06-05 2014-06-06           2014-06-18   Recover m     \n## 10 1389ca          4 NA             2014-06-05 2014-06-07           2014-06-09   Death   f     \n## # ℹ 5,878 more rows\n## # ℹ 22 more variables: age <dbl>, age_unit <chr>, age_years <dbl>, age_cat <fct>, age_cat5 <fct>,\n## #   hospital <chr>, lon <dbl>, lat <dbl>, infector <chr>, source <chr>, wt_kg <dbl>, ht_cm <dbl>,\n## #   ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>, vomit <chr>, temp <dbl>,\n## #   time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>\n## \n##   // contacts\n## \n## # A tibble: 3,800 × 4\n##    from   to     location   duration\n##    <chr>  <chr>  <chr>         <int>\n##  1 f547d6 5fe599 Community         8\n##  2 f90f5f b8812a Nosocomial        5\n##  3 11f8ea 893f25 Community         2\n##  4 aec8ec be99c8 Community         4\n##  5 893f25 07e3e8 Nosocomial        7\n##  6 133ee7 369449 Nosocomial        4\n##  7 996f3a 2978ac Community         9\n##  8 133ee7 57a565 Community         8\n##  9 37a6f6 fc15ef Nosocomial        8\n## 10 9f6884 2eaa9a Nosocomial        3\n## # ℹ 3,790 more rows"},{"path":"transmission_chains.html","id":"manipulation","chapter":"3 Chaînes de transmission","heading":"3.3 Manipulation","text":"","code":""},{"path":"transmission_chains.html","id":"sous-ensemble","chapter":"3 Chaînes de transmission","heading":"Sous-ensemble","text":"La méthode subset() pour les objets epicontacts permet, entre autres, de filtrer les réseaux en fonction des propriétés de la linelinst (“attributs de noeuds”) et de la jeu de données de contacts (“attributs de bords”).Ces valeurs doivent être passées comme des listes nommées à l’argument respectif. Par exemple, dans le code ci-dessous, nous ne gardons dans la linelist que les cas masculins qui ont une date d’infection entre avril et juillet 2014 (les dates sont spécifiées en tant que plages) et des liens de transmission qui ont eu lieu dans l’hôpital.Nous pouvons utiliser la fonction thin pour filtrer la linelist afin d’inclure les cas trouvés dans les contacts en définissant l’argument = \"linelist\", ou pour filtrer les contacts pour inclure les cas qui sont trouvés dans la linelist en définissant l’argument = \"contacts\". Dans le code ci-dessous, nous filtrons davantage l’objet epicontacts pour ne garder que les liens de transmission impliquant les cas masculins infectés entre avril et juillet que nous avons filtrés ci-dessus. Nous pouvons voir que seulement deux liens de transmission correspondent à cette spécification.Les réseaux peuvent être élagués pour n’inclure que les composants qui sont connectés à certains noeuds. L’argument cluster_id\nprend un vecteur d’identifiants de cas et renvoie la linelist des individus qui sont liés, directement ou indirectement, à ces IDs. Dans le code ci-dessous, nous pouvons voir qu’un total de 13 cas de la linelist sont impliqués dans les clusters contenant 2ae019 et 71577a.La méthode subset() pour les objets epicontacts permet aussi de filtrer par la taille des cluster en utilisant les arguments cs, cs_min et cs_max. Dans le code ci-dessous, nous gardons seulement les cas liés à des clusters de 10 cas ou plus, et nous pouvons voir que 271 cas de la linelist sont impliqués dans de tels clusters.","code":"\nsub_attributes <- subset(\n  epic,\n  node_attribute = list(\n    gender = \"m\",\n    date_infection = as.Date(c(\"2014-04-01\", \"2014-07-01\"))\n  ), \n  edge_attribute = list(location = \"Nosocomial\")\n)\nsub_attributes## \n## /// Epidemiological Contacts //\n## \n##   // class: epicontacts\n##   // 69 cases in linelist; 1,888 contacts; directed \n## \n##   // linelist\n## \n## # A tibble: 69 × 30\n##    id     generation date_infection date_onset date_hospitalisation date_outcome outcome gender\n##    <chr>       <dbl> <date>         <date>     <date>               <date>       <chr>   <chr> \n##  1 5fe599          4 2014-05-08     2014-05-13 2014-05-15           NA           <NA>    m     \n##  2 893f25          3 2014-05-18     2014-05-21 2014-05-22           2014-05-29   Recover m     \n##  3 2978ac          4 2014-05-30     2014-06-06 2014-06-08           2014-06-15   Death   m     \n##  4 57a565          4 2014-05-28     2014-06-13 2014-06-15           NA           Death   m     \n##  5 fc15ef          6 2014-06-14     2014-06-16 2014-06-17           2014-07-09   Recover m     \n##  6 99e8fa          7 2014-06-24     2014-06-28 2014-06-29           2014-07-09   Recover m     \n##  7 f327be          6 2014-06-14     2014-07-12 2014-07-13           2014-07-14   Death   m     \n##  8 90e5fe          5 2014-06-18     2014-07-13 2014-07-14           2014-07-16   <NA>    m     \n##  9 a47529          5 2014-06-13     2014-07-17 2014-07-18           2014-07-26   Death   m     \n## 10 da8ecb          5 2014-06-20     2014-07-18 2014-07-20           2014-08-01   <NA>    m     \n## # ℹ 59 more rows\n## # ℹ 22 more variables: age <dbl>, age_unit <chr>, age_years <dbl>, age_cat <fct>, age_cat5 <fct>,\n## #   hospital <chr>, lon <dbl>, lat <dbl>, infector <chr>, source <chr>, wt_kg <dbl>, ht_cm <dbl>,\n## #   ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>, vomit <chr>, temp <dbl>,\n## #   time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>\n## \n##   // contacts\n## \n## # A tibble: 1,888 × 4\n##    from   to     location   duration\n##    <chr>  <chr>  <chr>         <int>\n##  1 f90f5f b8812a Nosocomial        5\n##  2 893f25 07e3e8 Nosocomial        7\n##  3 133ee7 369449 Nosocomial        4\n##  4 37a6f6 fc15ef Nosocomial        8\n##  5 9f6884 2eaa9a Nosocomial        3\n##  6 8e104d ddddee Nosocomial        7\n##  7 ab634e 99e8fa Nosocomial        6\n##  8 b799eb bc2adf Nosocomial       10\n##  9 a15e13 f327be Nosocomial        1\n## 10 ea3740 90e5fe Nosocomial        7\n## # ℹ 1,878 more rows\nsub_attributes <- thin(sub_attributes, what = \"contacts\")\nnrow(sub_attributes$contacts)## [1] 2\nsub_id <- subset(epic, cluster_id = c(\"2ae019\", \"71577a\"))\nnrow(sub_id$linelist)## [1] 13\nsub_cs <- subset(epic, cs_min = 10)\nnrow(sub_cs$linelist)## [1] 271"},{"path":"transmission_chains.html","id":"accéder-les-ids","chapter":"3 Chaînes de transmission","heading":"Accéder les IDs","text":"La fonction get_id() récupère les informations sur les IDs des cas dans les\ndonnées, et peut être paramétrée comme la suite:linelist : IDs dans les données de la linelistcontacts : IDs dans la jeu de données des contacts (“” et “” combinés): IDs dans la colonne “” de la base de données des contacts.: IDs dans la colonne “” du jeu de données des contactsall : IDs qui apparaissent n’importe où dans l’un ou l’autre des jeu de données.common : IDs qui apparaissent à la fois dans la jeu de données des contacts et dans la linelist.Par exemple, quels sont les dix premiers ID dans la jeu de données des contacts ?Combien d’identifiants sont trouvés à la fois dans la linelist et dans les contacts ?","code":"\ncontacts_ids <- get_id(epic, \"contacts\")\nhead(contacts_ids, n = 10)##  [1] \"f547d6\" \"f90f5f\" \"11f8ea\" \"aec8ec\" \"893f25\" \"133ee7\" \"996f3a\" \"37a6f6\" \"9f6884\" \"4802b1\"\nlength(get_id(epic, \"common\"))## [1] 4352"},{"path":"transmission_chains.html","id":"visualisation","chapter":"3 Chaînes de transmission","heading":"3.4 Visualisation","text":"","code":""},{"path":"transmission_chains.html","id":"graphique-de-base","chapter":"3 Chaînes de transmission","heading":"Graphique de base","text":"Toutes les visualisations des objets epicontacts sont gérées par la fonction plot. Nous allons d’abord filtrer l’objet epicontacts pour n’inclure que les cas ayant une date d’apparition en juin 2014, en utilisant la fonction subset, et filtrer seulement les contacts liés à ces cas à l’aide de la fonction thin.Nous pouvons ensuite créer le graphique interactif de base très simplement comme suit :Vous pouvez déplacer les noeuds en les faisant glisser, les survoler pour obtenir plus d’informations et cliquer dessus pour subligner les cas connectés.Il existe un grand nombre d’arguments pour modifier ce graphique. Nous allons couvrir les principaux ici, mais consultez la documentation via ?vis_epicontacts (la fonction appelée lors de l’utilisation de plot sur un objet epicontacts) pour obtenir une description complète des arguments de la fonction.","code":"\n## sous-ensemble objet epicontacts\nsub <- epic %>%\n  subset(\n    node_attribute = list(date_onset = c(as.Date(c(\"2014-06-30\", \"2014-06-01\"))))\n  ) %>%\n thin(\"contacts\")\n## tracer l'objet epicontacts\nplot(\n  sub,\n  width = 700,\n  height = 700\n)"},{"path":"transmission_chains.html","id":"visualiser-les-attributs-des-noeuds","chapter":"3 Chaînes de transmission","heading":"Visualiser les attributs des noeuds","text":"La couleur, la forme et la taille d’un noeud peuvent être associées à une colonne specifiée de la linelist, en utilisant les arguments node_color, node_shape et node_size. Ceci est similaire à la syntaxe aes de ggplot2.Les couleurs, formes et tailles spécifiques des noeuds peuvent être spécifiées comme suit :Couleurs via l’argument col_pal, soit en fournissant une liste de noms pour la spécification manuelle de chaque couleur comme fait ci-dessous, ou en fournissant une fonction de palette de couleurs, telle que colorRampPalette(c(\"black\", \"red\", \"orange\")) fournira un gradient de couleurs entre les trois spécifiées.Couleurs via l’argument col_pal, soit en fournissant une liste de noms pour la spécification manuelle de chaque couleur comme fait ci-dessous, ou en fournissant une fonction de palette de couleurs, telle que colorRampPalette(c(\"black\", \"red\", \"orange\")) fournira un gradient de couleurs entre les trois spécifiées.Shapes en passant une liste nommée à l’argument shapes, et en spécifiant une forme pour chaque élément unique dans la colonne de la linelist spécifiée avec l’argument node_shape. Voir codeawesome pour les formes disponibles.Shapes en passant une liste nommée à l’argument shapes, et en spécifiant une forme pour chaque élément unique dans la colonne de la linelist spécifiée avec l’argument node_shape. Voir codeawesome pour les formes disponibles.Taille en passant une gamme de taille des noeuds à l’argument size_range.Taille en passant une gamme de taille des noeuds à l’argument size_range.Voici un exemple, où la couleur représente le résultat, la forme le sexe et la taille l’âge :","code":"\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = \"age\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  height = 700,\n  width = 700\n)"},{"path":"transmission_chains.html","id":"visualisation-des-attributs-de-bords","chapter":"3 Chaînes de transmission","heading":"Visualisation des attributs de bords","text":"La couleur, la largeur et le type de ligne de le bords peuvent être associés à une colonne du jeu de données contacts en utilisant les arguments edge_color, edge_width et edge_linetype, comme la suite:Couleurs via l’argument edge_col_pal, de la même manière que pour col_pal.Couleurs via l’argument edge_col_pal, de la même manière que pour col_pal.Largeurs en passant une gamme de taille des noeuds à l’argument width_range.Largeurs en passant une gamme de taille des noeuds à l’argument width_range.Voici un exemple :","code":"\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = \"age\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  edge_color = 'location',\n  edge_linetype = 'location',\n  edge_width = 'duration',\n  #edge_col_pal = c(Community = \"orange\", Nosocomial = \"violet\"),\n  width_range = c(1, 3),\n  height = 700,\n  width = 700\n)"},{"path":"transmission_chains.html","id":"axe-temporel","chapter":"3 Chaînes de transmission","heading":"Axe temporel","text":"Nous pouvons également visualiser le réseau selon un axe temporel en faisant correspondre l’argument x_axis à une colonne de la linelist. Dans l’exemple ci-dessous, l’axe des x représente la date d’apparition des symptômes. Nous avons également spécifié l’argument arrow_size pour nous assurer que les flèches ne sont pas trop grandes, et nous avons défini label = FALSE pour rendre la figure moins encombrée.Il existe un grand nombre d’arguments supplémentaires pour spécifier d’avantage la façon dont ce réseau est visualisé le long d’un axe temporel, que vous pouvez vérifier via ?vis_temporal_interactive (la fonction appelée lors de l’utilisation de plot sur un objet epicontacts avec x_axis spécifié). Nous allons voir quelques examples ci-dessous.","code":"\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)"},{"path":"transmission_chains.html","id":"spécifier-la-forme-de-larbre-de-transmission","chapter":"3 Chaînes de transmission","heading":"Spécifier la forme de l’arbre de transmission","text":"Il y deux formes principales que l’arbre de transmission peut prendre, spécifiées en utilisant l’argument network_shape. La première est une forme branchée comme indiqué ci-dessus, où un bord droite relie deux noeuds connectes. C’est la représentation la plus intuitive mais elle peut donner lieu à des bords qui se chevauchent dans un réseau dense. La deuxième forme est le rectangle, qui produit un arbre ressemblant à une phylogénie. Par exemple :peut assigner à chaque noud de cas une position verticale unique en modifiant l’argument position_dodge. La position des cas non liés (c’est-à-dire sans contacts signalés) est spécifiée à l’aide de l’argument unlinked_pos.La position du noeud parent par rapport aux noeuds enfants peut être spécifiée en utilisant l’argument parent_pos. L’option par défaut est de placer le noeud parent au milieu, mais il peut être placé en bas (parent_pos = 'bottom') ou en haut (parent_pos = 'top').","code":"\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  position_dodge = TRUE,\n  unlinked_pos = \"bottom\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  hieght = 700,\n  width = 700\n)\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)"},{"path":"transmission_chains.html","id":"enregistrement-des-graphiques-et-des-figures","chapter":"3 Chaînes de transmission","heading":"Enregistrement des graphiques et des figures","text":"Vous pouvez enregistrer un graphique sous forme de fichier html interactif et autonome avec la fonction visSave du paquet VisNetwork :L’enregistrement de ces sorties de réseau sous forme d’image est malheureusement moins facile et nécessite d’enregistrer le fichier en tant que html et ensuite de faire une capture d’écran utilisant le paquet webshot. Dans le code ci-dessous, nous convertissons le fichier html sauvegardé ci-dessus en un PNG :","code":"\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n) %>%\n  visNetwork::visSave(\"network.html\")\nwebshot(url = \"network.html\", file = \"network.png\")"},{"path":"transmission_chains.html","id":"ligne-chronologique","chapter":"3 Chaînes de transmission","heading":"Ligne chronologique","text":"Vous pouvez également ajouter les chronologie de cas sur le réseau, qui sont représentées sur l’axe des x de chaque cas. Ceci peut être utilisé pour visualiser localisations des cas, par exemple, ou le temps jusqu’au résultat. Pour générer une ligne chronologique, nous devons créer un dataframe d’au moins trois colonnes indiquant l’ID du cas, la date de début de l’“événement” et la date de fin de l’“événement”. Vous pouvez également ajouter n’importe quel nombre d’autres colonnes qui peuvent ensuite être mappées aux noeuds et aux bords. Dans le code ci-dessous, nous générons une ligne chronologique allant de la date de l’apparition des symptômes à la date du résultat. Nous conservons les variables de résultat et d’hôpital que nous utilisons pour définir la forme et la couleur des noeuds. Notez que vous pouvez avoir plus qu’une ligne/événement chronologique par cas, par exemple si un cas etait transféré entre plusieurs hôpitaux.Nous passons ensuite l’élément chronologique à l’argument timeline. Nous pouvons faire correspondre les attributs de la ligne chronologique aux couleurs, formesm et tailles des noeuds de la même manière que celle définie dans les sections précédentes, sauf que nous avons deux noeuds: le noeud de début et de fin de chaque ligne chronologique qui ont des arguments distincts. Par exemple, tl_start_node_color définit quelle colonne de la ligne chronologique est mappée à la couleur du noeud de départ, tandis que tl_end_node_shape définit quelle colonne de la ligne chronologique est utilise pour la forme du noeud final. Nous pouvons également faire correspondre la couleur, la largeur, le type de ligne et les étiquettes de bord de la ligne chronologique via les arguments tl_edge_*.Voir ?vis_temporal_interactive (la fonction appelée de plot() avec un objet epicontacts) pour plus de détails. Chaque argument est également annoté dans le code ci-dessous :","code":"\n## générer une ligne chronologique\ntimeline <- linelist %>%\n  transmute(\n    id = case_id,\n    start = date_onset,\n    end = date_outcome,\n    outcome = outcome,\n    hospital = hospital\n  )\n## définir les formes\nshapes <- c(\n  f = \"female\",\n  m = \"male\",\n  Death = \"user-times\",\n  Recover = \"heartbeat\",\n  \"NA\" = \"question-circle\"\n)\n\n## définir les couleurs\ncolours <- c(\n  Death = \"firebrick\",\n  Recover = \"green\",\n  \"NA\" = \"grey\"\n)\n\n## faire un graphique\nplot(\n  sub,\n  ## coordonnée x maximale de la date d'apparition de la maladie\n  x_axis = \"date_onset\",\n  ## utiliser une forme de réseau rectangulaire\n  network_shape = \"rectangle\",\n  ## mappe les formes de noeuds de cas à la colonne de sexe\n  node_shape = \"gender\",\n  ## nous ne voulons pas mapper la couleur des noeuds à aucune colonne, cela est important car la valeur par défaut est de mapper à l'id du noeud, ce qui va perturber le schéma de couleurs\n  node_color = NULL,\n  ## définir la taille du noeud de cas à 30 (comme il ne s'agit pas d'un caractère, node_size n'est pas mappée à une colonne mais interprétée comme la taille réelle du noeud)\n  node_size = 30,\n  ## définir la largeur du lien de transmission à 4 (comme il ne s'agit pas d'un caractère, edge_width n'est pas affectée à une colonne mais interprétée comme la largeur réelle du bord)\n  edge_width = 4,\n  ## fournir l'objet ligne chronologique\n  timeline = timeline,\n  ## mappe la forme du noeud de fin à la colonne de résultat dans l'objet de ligne chronologique\n  tl_end_node_shape = \"outcome\",\n  ## définir la taille du noeud final à 15 (comme il ne s'agit pas d'un caractère, cet argument n'est pas associé à la colonne des résultats dans l'objet ligne  chronologique).\n  tl_end_node_size = 15,\n  ## mappez la couleur du bord de la ligne de temps à la colonne de l'hôpital\n  tl_edge_color = \"hospital\",\n  ## Définir la largeur du bord de la ligne de temps à 2 (comme il ne s'agit pas d'un caractère, cet argument n'est pas associé à la colonne de l'hôpital).\n  tl_edge_width = 2,\n  ## mappez les étiquettes des bords à la variable hospital\n  tl_edge_label = \"hospital\",\n  ## spécifier la forme pour chaque attribut de noeud (défini ci-dessus)\n  shapes = shapes,\n  ## spécifier la palette de couleurs (définie ci-dessus)\n  col_pal = colours,\n  ## définir la taille de la flèche à 0.5\n  arrow_size = 0.5,\n  ## utiliser deux colonnes dans la légende\n  legend_ncol = 2,\n  ## définir la taille de la police\n  font_size = 15,\n  ## définir le formatage des dates\n  date_labels = c(\"%d %b %Y\"),\n  ## ne pas tracer les étiquettes d'identification sous les noeuds\n  label = FALSE,\n  ## spécifier la hauteur\n  height = 1000,\n  ## spécifier la largeur\n  width = 1200,\n  ## assurez-vous que chaque noeud de cas a une coordonnée y unique, ceci est très important\n  ## lors de l'utilisation de lignes chronologiques, sinon les lignes chronologiques se chevauchant de différents cas\n  position_dodge = TRUE\n)## Warning in assert_timeline(timeline, x, x_axis): 5865 timeline row(s) removed as ID not found in\n## linelist or start/end date is NA"},{"path":"transmission_chains.html","id":"analyse","chapter":"3 Chaînes de transmission","heading":"3.5 Analyse","text":"","code":""},{"path":"transmission_chains.html","id":"résumé","chapter":"3 Chaînes de transmission","heading":"Résumé","text":"Nous pouvons obtenir un aperçu de certaines propriétés du réseau en utilisant la fonction summary.Par exemple, nous pouvons voir que seulement 57% des contacts ont les deux cas dans la linelist ; cela signifie que nous ne disposons pas de données de le linelist sur un nombre significatif de cas impliqués dans ces chaînes de transmission.","code":"\n## résumer l'objet epicontacts\nsummary(epic)## \n## /// Overview //\n##   // number of unique IDs in linelist: 5888\n##   // number of unique IDs in contacts: 5511\n##   // number of unique IDs in both: 4352\n##   // number of contacts: 3800\n##   // contacts with both cases in linelist: 56.868 %\n## \n## /// Degrees of the network //\n##   // in-degree summary:\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##  0.0000  0.0000  1.0000  0.5392  1.0000  1.0000 \n## \n##   // out-degree summary:\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##  0.0000  0.0000  0.0000  0.5392  1.0000  6.0000 \n## \n##   // in and out degree summary:\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   0.000   1.000   1.000   1.078   1.000   7.000 \n## \n## /// Attributes //\n##   // attributes in linelist:\n##  generation date_infection date_onset date_hospitalisation date_outcome outcome gender age age_unit age_years age_cat age_cat5 hospital lon lat infector source wt_kg ht_cm ct_blood fever chills cough aches vomit temp time_admission bmi days_onset_hosp\n## \n##   // attributes in contacts:\n##  location duration"},{"path":"transmission_chains.html","id":"caractéristiques-par-paires","chapter":"3 Chaînes de transmission","heading":"Caractéristiques par paires","text":"La fonction get_pairwise() permet de traiter les variables de la linelist en fonction de chaque paire dans l’ensemble de données de contact. Dans l’exemple suivant, la date d’apparition de la maladie est extraite de la liste de lignes afin de calculer la différence entre la date d’apparition de la maladie pour chaque paire dans l’ensemble de données de contact. La valeur produite par cette comparaison représente l’ intervalle de série (si).La fonction get_pairwise() va interpréter la classe de la colonne utilisée pour la comparaison, et adaptera sa méthode de comparaison des valeurs en conséquence. Pour les nombres et les dates (comme l’exemple si ci-dessus), la fonction va soustraire les valeurs. Lorsqu’elle est appliquée à des colonnes qui sont des caractères ou des catégories,\nget_pairwise() collera les valeurs ensemble. Comme la fonction permet également un traitement arbitraire (voir l’argument “f”), ces combinaisons discrètes peuvent être facilement mises en tableau et analysées.Ici, nous voyons une association significative entre les liens de transmission et le sexe.","code":"\nsi <- get_pairwise(epic, \"date_onset\")   \nsummary(si)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    5.00    9.00   11.01   15.00   99.00    1820\ntibble(si = si) %>%\n  ggplot(aes(si)) +\n  geom_histogram() +\n  labs(\n    x = \"Intervalle de série\",\n    y = \"Fréquence\"\n  )## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.## Warning: Removed 1820 rows containing non-finite values (`stat_bin()`).\nhead(get_pairwise(epic, \"gender\"), n = 10)##  [1] \"f -> m\" NA       \"m -> m\" NA       \"m -> f\" \"f -> f\" NA       \"f -> m\" NA       \"m -> f\"\nget_pairwise(epic, \"gender\", f = table)##            values.to\n## values.from   f   m\n##           f 464 516\n##           m 510 468\nfisher.test(get_pairwise(epic, \"gender\", f = table))## \n##  Fisher's Exact Test for Count Data\n## \n## data:  get_pairwise(epic, \"gender\", f = table)\n## p-value = 0.03758\n## alternative hypothesis: true odds ratio is not equal to 1\n## 95 percent confidence interval:\n##  0.6882761 0.9892811\n## sample estimates:\n## odds ratio \n##  0.8252575"},{"path":"transmission_chains.html","id":"identifier-les-clusters","chapter":"3 Chaînes de transmission","heading":"Identifier les clusters","text":"La fonction get_clusters() peut être utilisée pour identifier les composants connectés dans un objet epicontacts. Tout d’abord, nous l’utilisons pour récupérer un data.frame contenant les informations sur les clusters :Examinons les plus grands clusters. Pour cela, nous ajoutons des informations sur les clusters à l’objet epicontacts, puis nous le sous-ensemblons pour ne garder que les plus grands clusters :","code":"\nclust <- get_clusters(epic, output = \"data.frame\")\ntable(clust$cluster_size)## \n##    1    2    3    4    5    6    7    8    9   10   11   12   13   14 \n## 1536 1680 1182  784  545  342  308  208  171  100   99   24   26   42\nggplot(clust, aes(cluster_size)) +\n  geom_bar() +\n  labs(\n    x = \"Taille des clusters\",\n    y = \"Fréquence\"\n  )\nepic <- get_clusters(epic)\nmax_size <- max(epic$linelist$cluster_size)\nplot(subset(epic, cs = max_size))"},{"path":"transmission_chains.html","id":"calcul-des-degrés","chapter":"3 Chaînes de transmission","heading":"Calcul des degrés","text":"Le degré d’un noeud correspond à son nombre de bords ou de connexions avec d’autres noeuds. get_degree() fournit une méthode simple pour calculer cette valeur pour les objets epicontacts. Un degré élevé dans ce contexte indique un individu qui était en contact avec beaucoup d’autres personnes. L’argument type indique que nous souhaitons compter à la fois le degré d’entrée et le degré de sortie, l’argument only_linelist indique que nous voulons calculer le degré pour les cas de la linelist.Quels sont les individus qui ont les dix plus grands contacts ?Quel est le nombre moyen de contacts ?","code":"\ndeg_both <- get_degree(epic, type = \"both\", only_linelist = TRUE)\nhead(sort(deg_both, decreasing = TRUE), 10)## 916d0a 858426 6833d7 f093ea 11f8ea 3a4372 38fc71 c8c4d5 a127a7 02d8fd \n##      7      6      6      6      5      5      5      5      5      5\nmean(deg_both)## [1] 1.078473"},{"path":"transmission_chains.html","id":"ressources-1","chapter":"3 Chaînes de transmission","heading":"3.6 Ressources","text":"Le site pour le paquet epicontacts fournit une vue d’ensemble des fonctions du paquet et contient quelques vignettes plus approfondies.La page github peut être utilisée pour soulever des\nproblèmes et demander des fonctionnalités.","code":""}]
